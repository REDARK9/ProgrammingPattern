<html><head><style>body {
   color: black;
}
</style></head><body><p><strong>UNITY FOR GAMES E-BOOK</strong></p>
<h2 id="l-e-v-e-l-u-p-y-o-u-r-c-o-d-e-w-i-t-h-g-a-m-e-p-r-o-g-r-a-m-m-i-n-g-pat-terns">L E V E L U P Y O U R C O D E W I T H G A M E P R O G R A M M I N G PAT TERNS</h2>
<p>2021 LTS EDITION</p>
<h3 id="-contents-"><strong>Contents</strong></h3>
<table>
<thead>
<tr>
<th></th>
<th>Introducing design patterns<br>4</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Using this guide and the KISS principle 6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>The SOLID principles 7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Single-responsibility principle 8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Open-closed principle 12</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Liskov substitution principle 15</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Interface segregation principle 21</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Dependency inversion principle 24</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Interfaces versus abstract classes 30</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Abstract classes 30</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Interfaces 32</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>A SOLID understanding 34</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Design patterns for game development 35</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>The Gang of Four 36</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Learning design patterns 36</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>References 37</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Patterns within Unity 37</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Factory pattern 39</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Example: A simple factory 40</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Pros and cons 43</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Improvements 44</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Object pool 45</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Example: Simple pool system 46</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Improvements 50</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>UnityEngine.Pool 50</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Singleton pattern 53</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Example: Simple singleton 55</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Persistence and lazy instantiation 56</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Using generics 58</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pros and cons 59</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Command pattern 61</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>The command object and command invoker 62</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Example: Undoable movement 63</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pros and cons 67</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Improvements 67</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>State pattern 69</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>States and state machines 70</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Example: Simple state pattern 72</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pros and cons 76</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Improvements 76</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Observer pattern 79</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Events 80</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Example: Simple subject and observer 82</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>UnityEvents and UnityActions 85</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pros and cons 86</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Improvements 86</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Model View Presenter (MVP) 88</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Model View Controller (MVC) design pattern 89</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Model View Presenter (MVP) and Unity 90</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Example: Health interface 91</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pros and cons 93</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Conclusion 95</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Other design patterns 96</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Professional Training for Unity creators 98</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="-span-id-page-3-0-span-i-n-t-r-o-d-u-c-i-n-g-design-pat-terns"><span id="page-3-0"></span>I N T R O D U C I N G DESIGN PAT TERNS</h1>
<p>When working in Unity, you don&#39;t have to reinvent the wheel. It&#39;s likely someone has already invented one for you.</p>
<p>For every software design issue you encounter, a thousand developers have been there before. While you can&#39;t always ask them directly for advice, you can learn from their decisions through design patterns.</p>
<p>Design patterns are general solutions to common problems found in software engineering. These aren&#39;t finished solutions that you can copy and paste into your code, but you can think of design patterns as extra tools in your toolbox. Some are more obvious than others.</p>
<p>This guide assembles well-known design patterns in Unity development. The examples in this guide have been simplified and technical jargon reduced, to make them more accessible, though you should have a working knowledge of C# basics before starting with them.</p>
<p>If you&#39;re still new to design patterns or need a quick refresher, the guide also provides common scenarios where you can apply them in game development. For those switching from another object-oriented language (Java, C++, etc.) to C#, these samples will show you how to adapt patterns specifically to Unity.</p>
<p>At the core of it, design patterns are just ideas. They won&#39;t apply in all situations. But they can help you build larger applications that scale when used correctly. Integrate them into your project to improve code readability and make your codebase cleaner. As you gain experience with patterns, you&#39;ll recognize when they can speed up your development process.</p>
<p>Then you can stop reinventing the wheel and, well, start working on something new.</p>
<h4 id="-contributors-"><strong>Contributors</strong></h4>
<p>This guide was written by Wilmer Lin, a 3D and visual effects artist with over 15 years of industry experience in film and television, who now works as an independent game developer and educator. Significant contributions were also made by senior technical content marketing manager Thomas Krogh-Jacobsen and senior Unity engineers Peter Andreasen and Scott Bilas.</p>
<h4 id="-span-id-page-5-0-span-using-this-guide-and-the-kiss-principle-"><span id="page-5-0"></span><strong>Using this guide and the KISS principle</strong></h4>
<p>This guide aims to present you with new ways of thinking about and organizing your code. Several patterns for software design highlighted in this guide are adapted to Unity development.</p>
<p>The included <a href="https://github.com/Unity-Technologies/game-programming-patterns-demo/">sample project</a> shows some of the code in context. Use the corresponding scenes to explore these design patterns and their underpinning principles.</p>
<p>However, when reviewing these examples, remember there isn&#39;t a blanket &quot;right way&quot; to approach a problem. The sample code is one solution among many.</p>
<p>When in doubt, filter everything in this guide through the <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle</a>: &quot;Keep it simple, stupid.&quot; Only add complexity if necessary.</p>
<p>Every design pattern comes with tradeoffs, whether that means additional structures to maintain or more setup at the beginning. Decide if the benefit justifies extra work before implementing it.</p>
<p>If you&#39;re unsure if a pattern applies to your specific problem, you might be better off waiting for a situation where it feels like a more natural fit. Don&#39;t use a pattern because it&#39;s new or novel to you; use it when you need it.</p>
<p>Then, the design pattern will serve its intended purpose: to help you develop better software.</p>
<p>Let&#39;s get started.</p>
<h1 id="-span-id-page-6-0-span-t-h-e-s-o-l-i-d-principles"><span id="page-6-0"></span>T H E S O L I D PRINCIPLES</h1>
<p><span id="page-7-0"></span>Before charging into the patterns themselves, let&#39;s look at some design principles that influence how they work.</p>
<p>SOLID is a mnemonic acronym for five core fundamentals of software design:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single responsibility</a></li>
<li><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open-closed</a></li>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface segregation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency inversion</a></li>
</ul>
<p>Let&#39;s examine each concept and see how they help you make your code more understandable, flexible, and maintainable.</p>
<h4 id="single-responsibility-principle">Single-responsibility principle</h4>
<p>A class should have one reason to change, just its single responsibility.</p>
<p>The first and most important SOLID principle is the <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">single-responsibility principle</a>  (SRP), which states that each module, class, or function is responsible for one thing and encapsulates only that part of the logic.</p>
<p>Assemble your projects from many smaller ones instead of building monolithic classes. Shorter classes and methods are easier to explain, understand, and implement.</p>
<p>If you&#39;ve worked in Unity for a while, you&#39;re likely already familiar with this concept. When you create a GameObject, it holds a variety of smaller components. For example, it might come with:</p>
<ul>
<li>A MeshFilter that stores a reference to the 3D model</li>
<li>A Renderer that controls how the model surface appears onscreen</li>
<li>A Transform component that stores scale, rotation, and position</li>
<li>A Rigidbody if it needs to interact with the physics simulation</li>
</ul>
<p>Each component does one thing and does it well. You build an entire scene from GameObjects. The interaction between their components is what makes a game possible.</p>
<p>You&#39;ll construct your scripted components in the same way. Design them so each one can be clearly understood. Then have them work in concert to make complex behavior.</p>
<p>If you ignore single responsibility, you might create a custom component that does this:</p>
<p><img src="_page_8_Picture_1.jpeg" alt=""></p>
<p>A Player script with multiple responsibilities</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnrefactoredPlayer</span> : <span class="hljs-title">MonoBehaviour</span>
{
 [SerializeField] <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> inputAxisName;
 [SerializeField] <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> positionMultiplier;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> yPosition;
 <span class="hljs-keyword">private</span> AudioSource bounceSfx;
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)
 </span>{
 bounceSfx = GetComponent&lt;AudioSource&gt;();
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">float</span> delta = Input.GetAxis(inputAxisName) * Time.deltaTime;
 yPosition = Mathf.Clamp(yPosition + delta, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);
 transform.position = <span class="hljs-keyword">new</span> Vector3(transform.position.x, yPosi-
tion * positionMultiplier, transform.position.z);
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)
 </span>{
 bounceSfx.Play();
 }
}
</code></pre><p>This UnrefactoredPlayer class has a mishmash of responsibilities. It plays a sound when a player collides with something, manages input, and handles movement. Even if the class is relatively short at the moment, it will become tricky to maintain as your project evolves. Consider breaking the Player class into smaller classes.</p>
<p><img src="_page_9_Figure_1.jpeg" alt=""></p>
<p>The Player, refactored into classes with single responsibilities</p>
<pre><code>[RequireComponent(<span class="hljs-keyword">typeof</span>(PlayerAudio), <span class="hljs-keyword">typeof</span>(PlayerInput), 
<span class="hljs-keyword">typeof</span>(PlayerMovement))]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> : <span class="hljs-title">MonoBehaviour</span>
{
 [SerializeField] <span class="hljs-keyword">private</span> PlayerAudio playerAudio;
 [SerializeField] <span class="hljs-keyword">private</span> PlayerInput playerInput;
 [SerializeField] <span class="hljs-keyword">private</span> PlayerMovement playerMovement;
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)
 </span>{
 playerAudio = GetComponent&lt;PlayerAudio&gt;();
 playerInput = GetComponent&lt;PlayerInput&gt;();
 playerMovement = GetComponent&lt;PlayerMovement&gt;();
 }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerAudio</span> : <span class="hljs-title">MonoBehaviour</span>
{
 …
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerInput</span> : <span class="hljs-title">MonoBehaviour</span>
{
 …
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerMovement</span> : <span class="hljs-title">MonoBehaviour</span>
{
 …
}
</code></pre><p>A Player script can still manage the other scripted components but each class does only one thing. This design makes it more approachable to revise the code, especially as the requirements for your project change over time.</p>
<p>On the other hand, however, you need to balance the single-responsibility principle with a good dose of common sense. Don&#39;t oversimplify to the extreme by creating classes with just one method.</p>
<p>Keep these objectives in mind when working with the single-responsibility principle:</p>
<ul>
<li><strong>Readability:</strong> Short classes are easier to read. There is no hard and fast rule but many developers set a limit of 200-300 lines. Determine for yourself or as a team what constitutes &quot;short.&quot; When you exceed this threshold, decide if you can refactor it into smaller parts.</li>
<li><strong>Extensibility:</strong> You can inherit from small classes more easily. Modify or replace them without fear of breaking unintended features.</li>
<li><strong>Reusability:</strong> Design your classes to be small and modular so that you can reuse them for other parts of your game.</li>
</ul>
<p>When refactoring, consider how rearranging code will improve the quality of life for yourself or other team members. Some extra effort at the beginning can save you a lot of trouble later.</p>
<h3 id="simple-is-not-easy">Simple is not easy</h3>
<p>Simplicity is often talked about in software design and is a prerequisite for reliability. Can your software design handle changes in production? Can you extend and maintain your application over time?</p>
<p>Many of the design patterns and principles presented in this guide help you enforce simplicity. In doing so, they make your code more scalable, flexible, and readable. However, they require some extra work and planning. &quot;Simple&quot; does not equate to &quot;easy.&quot;</p>
<p>Though you can create the same functionality without the patterns (and often more quickly), something fast and easy doesn&#39;t necessarily result in something simple. Making something simple means making it focused. Design it to do one thing, and don&#39;t overcomplicate it with other tasks.</p>
<p>Check out Rich Hickey&#39;s lecture, <a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple Made Easy</a>, to understand how simplicity can help you build better software.</p>
<h4 id="-span-id-page-11-0-span-open-closed-principle"><span id="page-11-0"></span>Open-closed principle</h4>
<p>The <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open-closed principle</a> (OCP) in SOLID design says that classes must be open for extension but closed for modification. Structure your classes so that you can create new behavior without modifying the original code.</p>
<p>A classic example of this is calculating the area of a shape. You can make a class called AreaCalculator with methods to return the area of a rectangle and circle.</p>
<p>For the sake of calculating area, a Rectangle class has a Width and Height. A Circle only needs a Radius and the value of pi.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> AreaCalculator 
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> GetRectangleArea(Rectangle rectangle)
 {
 <span class="hljs-built_in">return</span> rectangle.<span class="hljs-built_in">width</span> * rectangle.<span class="hljs-built_in">height</span>;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> GetCircleArea(Circle <span class="hljs-built_in">circle</span>)
 {
 <span class="hljs-built_in">return</span> <span class="hljs-built_in">circle</span>.radius * <span class="hljs-built_in">circle</span>.radius * Mathf.PI;
 }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Rectangle
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-built_in">width</span>;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-built_in">height</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Circle
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> radius;
}
</code></pre><p>This works well enough, but if you want to add more shapes to your AreaCalculator, you&#39;ll need to create a new method for each new shape. Suppose you want to pass it a pentagon or an octagon later? What if you need 20 more shapes? The AreaCalculator class would quickly balloon out of control.</p>
<p>You could make a base class called Shape and create one method to process the shapes. However, doing so would require multiple if statements inside the logic to handle each type of shape. That won&#39;t scale well.</p>
<p>You want to open the program for extension (the ability to use new shapes) without modifying the original code (the internals of the AreaCalculator). Though it&#39;s functional, the current AreaCalculator violates the open-closed principle.</p>
<p><img src="_page_12_Figure_0.jpeg" alt=""></p>
<p>How do we design the AreaCalculator to take new shapes?</p>
<p>Instead, consider defining an abstract Shape class:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>
{
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">float</span> <span class="hljs-title">CalculateArea</span>(<span class="hljs-params"></span>)</span>;
}
</code></pre><p>This includes an abstract method called CalculateArea. If you then make Rectangle and Circle inherit from Shape, each shape can calculate its own area and return the following result:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">Shape</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> width;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> height;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">float</span> <span class="hljs-title">CalculateArea</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">return</span> width * height;
 }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> radius;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">float</span> <span class="hljs-title">CalculateArea</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">return</span> radius * radius * Mathf.PI; 
 }
}
</code></pre><p>The AreaCalculator can simplify into this:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> AreaCalculator 
{
 <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> GetArea(<span class="hljs-built_in">Shape</span> <span class="hljs-built_in">shape</span>)
 {
 <span class="hljs-keyword">return</span> <span class="hljs-built_in">shape</span>.CalculateArea();
 }
}
</code></pre><p>The revised AreaCalculator class can now get the area of any shape that properly implements the abstract Shape class. You can then extend the AreaCalculator functionality without changing any of its original source.</p>
<p><img src="_page_13_Figure_3.jpeg" alt=""></p>
<p>Revising the classes for the open-closed principle</p>
<p>Every time you need a new polygon, simply define a new class that inherits from Shape. Each subclassed shape then overrides the CalculateArea method to return the correct area.</p>
<p>This new design makes debugging easier. If a new shape introduces an error, you don&#39;t have to revisit the AreaCalculator. The old code remains unchanged, so you only need to examine new code for any faulty logic.</p>
<p>Take advantage of interfaces and abstraction when creating new classes in Unity. This helps to avoid unwieldy switch or if statements in your logic that will be difficult to extend later. Once you get accustomed to setting up your classes to respect OCP, adding new code in the long term becomes simpler.</p>
<h4 id="-span-id-page-14-0-span-liskov-substitution-principle"><span id="page-14-0"></span>Liskov substitution principle</h4>
<p>The <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a> (LSP) states that derived classes must be substitutable for their base class. Inheritance in object-oriented programming allows you to add functionality through subclasses. However, this can lead to unnecessary complexity if you&#39;re not careful.</p>
<p>The Liskov substitution principle, the third pillar of SOLID, tells you how to apply inheritance to make your subclasses more robust and flexible.</p>
<p>Imagine your game requires a class called Vehicle. This will be the base class of a vehicle subclass that you will create for your application. For example, you might need a car or truck.</p>
<p><img src="_page_14_Figure_4.jpeg" alt=""></p>
<p>Everything inherits from Vehicle.</p>
<p>Everywhere you can use the base class (Vehicle), you should be able to use a subclass like Car or Truck without breaking the application.</p>
<p>Your Vehicle class might look like this:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">100</span>;
 <span class="hljs-keyword">public</span> Vector3 direction;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoForward</span>(<span class="hljs-params"></span>)
 </span>{
 ...
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params"></span>)
 </span>{
 ...
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnRight</span>(<span class="hljs-params"></span>)
 </span>{
 ...
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnLeft</span>(<span class="hljs-params"></span>)
 </span>{
 ...
 }
}
</code></pre><p>Suppose you are building a turn-based game where you move the vehicles around a board.</p>
<p><img src="_page_15_Figure_3.jpeg" alt=""></p>
<p>An example game of cars versus trains</p>
<p>You could have another class called Navigator to steer a vehicle along a prescribed path:</p>
<pre><code>public class Navigator
{
 public void <span class="hljs-built_in">Move</span>(<span class="hljs-built_in">Vehicle</span> <span class="hljs-built_in">vehicle</span>)
 {
 <span class="hljs-built_in">vehicle</span>.GoForward();
 <span class="hljs-built_in">vehicle</span>.TurnLeft();
 <span class="hljs-built_in">vehicle</span>.GoForward();
 <span class="hljs-built_in">vehicle</span>.TurnRight();
 <span class="hljs-built_in">vehicle</span>.GoForward();
 }
}
</code></pre><p>With this class, you expect to be able to pass any vehicle into the Navigator&#39;s Move method, and this will work fine with cars and trucks. What happens, though, when you want to implement a class called Train?</p>
<p><img src="_page_16_Figure_3.jpeg" alt=""></p>
<p>A Train would violate your base class.</p>
<p>The TurnLeft and TurnRight methods would not work in a Train class since a train can&#39;t leave its tracks. If you do pass a train into the Navigator&#39;s Move method, that would throw an unimplemented Exception (or do nothing) when you get to those lines. You violate the Liskov substitution principle if you cannot substitute a type for its subtype.</p>
<p>Since a Train is a subtype of Vehicle, you would expect to use it any place that accepts the Vehicle class. Doing otherwise might make your code behave unpredictably.</p>
<p>Consider some tips to adhere more closely to Liskov substitution principle:</p>
<ul>
<li><strong>If you are removing features when subclassing, you are likely breaking Liskov substitution:</strong> A NotImplementedException is a dead giveaway that you&#39;ve violated this principle. Leaving a method blank does so as well. If the subclass does not behave like the base class, you&#39;re not following LSP – even if there&#39;s no explicit error or exception.</li>
<li><strong>Keep abstractions simple:</strong> The more logic you put into the base class the more likely you will break LSP. The base class should only express the common functionality of the derived subclasses.</li>
<li><strong>A subclass needs to have the same public members as the base class:</strong>  Those members also need to have the same signatures and behavior when calling them.</li>
<li><strong>Consider the class API before establishing class hierarchies:</strong> Even though you think of them all as vehicles, it might make more sense for a Car and Train to inherit from separate parent classes. Classifications in reality don&#39;t always translate into class hierarchy.</li>
<li><strong>Favor composition over inheritance:</strong> Instead of trying to pass functionality through inheritance, create an interface or separate class to encapsulate a specific behavior. Then build up a &quot;composition&quot; of different functionality by mixing and matching.</li>
</ul>
<p><img src="_page_17_Figure_7.jpeg" alt=""></p>
<p>Composition over inheritance</p>
<p>To fix this design, scrap the original Vehicle type, then move much of the functionality into interfaces:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ITurnable</span> 
{
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnRight</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnLeft</span>(<span class="hljs-params"></span>)</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMovable</span>
{
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoForward</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params"></span>)</span>;
}
</code></pre><p>Follow the LSP principle more closely by creating a RoadVehicle type and RailVehicle type. The Car and Train would then inherit from their respective base classes.</p>
<p><img src="_page_18_Figure_3.jpeg" alt=""></p>
<p>Refactoring to take Liskov substitution into consideration</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> RoadVehicle : IMovable, ITurnable
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">100f</span>;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> turnSpeed = <span class="hljs-number">5f</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoForward</span><span class="hljs-params">()</span>
 </span>{
 ...
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span>
 </span>{
 ... 
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnLeft</span><span class="hljs-params">()</span>
 </span>{
 ... 
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnRight</span><span class="hljs-params">()</span>
 </span>{
 ... 
 }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> RailVehicle : IMovable
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">100</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoForward</span><span class="hljs-params">()</span>
 </span>{
 ...
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span>
 </span>{
 ...
 }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Car : RoadVehicle
{
 ...
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Train : RailVehicle
{
 ...
}
</code></pre><p><span id="page-20-0"></span>In this way the functionality comes through interfaces rather than inheritance. Car and Train no longer share the same base class, which now satisfies LSP. Though you could derive RoadVehicle and RailVehicle from the same base class, there is not much need to in this case.</p>
<p>This way of thinking can be counterintuitive because you have certain assumptions about the real world. In software development, this is called the circle–ellipse problem. Not every actual &quot;is a&quot; relationship translates into inheritance. Remember, you want your software design to drive your class hierarchy, not your prior knowledge of reality.</p>
<p>Follow the Liskov substitution principle to limit how you use inheritance to keep your codebase extendable and flexible.</p>
<p>Interface segregation principle</p>
<p>The <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">interface segregation principle</a> (ISP) states that no client should be forced to depend on methods it does not use.</p>
<p>In other words, avoid large interfaces. Follow the same idea as the singleresponsibility principle, which tells you to keep classes and methods short. This gives you maximum flexibility, keeping interfaces compact and focused.</p>
<p>Imagine you&#39;re making a strategy game with different player units. Each unit has different stats like health and speed. You might want to make an interface to guarantee that all of the units implement similar features:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnitStats</span> 
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Health { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Defense { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Die</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RestoreHealth</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> MoveSpeed { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Acceleration { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoForward</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnLeft</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnRight</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Strength { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Dexterity { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Endurance { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre><p>Let&#39;s say you want to make a destructible prop like a breakable barrel or crate. This prop will also need the concept of health despite not moving. A crate or barrel also won&#39;t have many of the abilities associated with other units in the game.</p>
<p>Split it into several smaller interfaces rather than make one interface that gives the breakable prop too many methods. A class implementing them will then only mix and match what it needs.</p>
<p><img src="_page_21_Figure_2.jpeg" alt=""></p>
<p>Split the interface into smaller ones.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMovable</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> MoveSpeed { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Acceleration { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoForward</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnLeft</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurnRight</span>(<span class="hljs-params"></span>)</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDamageable</span> 
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Health { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Defense { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Die</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RestoreHealth</span>(<span class="hljs-params"></span>)</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnitStats</span> 
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Strength { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Dexterity { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Endurance { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre><p>You can also add an IExplodable interface for the exploding barrel:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IExplodable</span> 
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Mass { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> ExplosiveForce { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> FuseDelay { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Explode</span>(<span class="hljs-params"></span>)</span>;
}
</code></pre><p><span id="page-23-0"></span>Because a class can implement more than one interface, you can compose an enemy unit from IDamageable, IMoveable, and IUnitStats.</p>
<p>An exploding barrel could use IDamageable and IExplodable without needing the unnecessary overhead of the other interfaces.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExplodingBarrel</span> : <span class="hljs-type">MonoBehaviour</span>, <span class="hljs-type">IDamageable</span>, <span class="hljs-type">IExplodable</span></span>
{
 ...
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnemyUnit</span> : <span class="hljs-type">MonoBehaviour</span>, <span class="hljs-type">IDamageable</span>, <span class="hljs-type">IMovable</span>, <span class="hljs-type">IUnit-</span></span>
Stats
{
 ...
}
</code></pre><p>Again, this favors <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance,</a> similar to the example with Liskov substitution. The interface segregation principle helps decouple your systems and makes them easier to modify and redeploy.</p>
<h4 id="dependency-inversion-principle">Dependency inversion principle</h4>
<p>The <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">dependency inversion principle</a> (DIP) says that high-level modules should not import anything directly from low-level modules. Both should depend on abstractions.</p>
<p>Let&#39;s unpack what that means. When one class has a relationship with another, it has a <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming">dependency or coupling.</a>) Each dependency in software design carries some risk.</p>
<p>If one class knows too much about how another class works, modifying the first class can damage the second or vice versa. A high degree of coupling is considered unclean code practice. An error in one part of the application can snowball into many.</p>
<p>Ideally, aim for as few dependencies between classes as possible. Each class also needs its internal parts to work together in unison, rather than relying on connections to the outside. Your object is considered cohesive when it functions on internal or private logic.</p>
<p>In the best scenario, aim for loose coupling and high cohesion.</p>
<p>Strive for loose coupling with high cohesion.</p>
<p>You need to be able to modify and expand your game application. If it&#39;s fragile and resistant to modification, investigate how it&#39;s currently structured.</p>
<p>The dependency inversion principle can help reduce this tight coupling between classes. When building classes and systems in your application, some are naturally &quot;high-level&quot; and some &quot;low-level.&quot; A high-level class depends on a lower-level class to get something done. SOLID tells us to switch this up.</p>
<p>Suppose you are making a game where a character explores the level and triggers a door to open. You might want to create a class called Switch and another class called Door.</p>
<p><img src="_page_25_Figure_1.jpeg" alt=""></p>
<h3 id="without-dependency-inversion">Without dependency inversion</h3>
<p>The Switch (high-level) depends directly on the Door (low-level) class.</p>
<p>On a high level, you want the character to move to a specific location and for something to happen. The Switch will be responsible for that.</p>
<p>On a low level is another class, Door, that contains the actual implementation of how to open the door geometry. For simplification, a Debug.Log statement is added to represent the logic of the opening and closing door.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Switch</span> : <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-keyword">public</span> Door door;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isActivated;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Toggle</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (isActivated)
 {
 isActivated = <span class="hljs-literal">false</span>;
 door.Close();
 }
 <span class="hljs-keyword">else</span>
 {
 isActivated = <span class="hljs-literal">true</span>;
 door.Open();
 }
 }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Door</span> : <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Open</span>(<span class="hljs-params"></span>)
 </span>{
 Debug.Log(<span class="hljs-string">"The door is open."</span>);
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Close</span>(<span class="hljs-params"></span>)
 </span>{
 Debug.Log(<span class="hljs-string">"The door is closed."</span>);
 }
}
</code></pre><p>Switch can invoke the Toggle method to open and close the door. It works, but the problem is that a dependency is wired from the Door directly into the Switch. What if the logic of the Switch needs to work on more than just a Door for example, to activate a light or giant robot?</p>
<p>You can add extra methods into the Switch class, but you&#39;d be violating the open-closed principle. You have to modify the original code every time you want to extend functionality.</p>
<p>Once again abstractions come to the rescue. You can sandwich an interface called ISwitchable in between your classes.</p>
<p><img src="_page_27_Figure_2.jpeg" alt=""></p>
<p>An interface, ISwitchable, between the two classes</p>
<p>ISwitchable just needs a public property so you know whether it&#39;s active, plus a couple of methods to Activate and Deactivate it.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISwitchable</span> 
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsActive { <span class="hljs-keyword">get</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Activate</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deactivate</span>(<span class="hljs-params"></span>)</span>;
}
</code></pre><p>Then the Switch becomes something like this, depending on an ISwitchable client, instead of a door directly.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Switch</span> : <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-keyword">public</span> ISwitchable client;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Toggle</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (client.IsActive)
 {
 client.Deactivate();
 }
 <span class="hljs-keyword">else</span>
 {
 client.Activate();
 }
 }
}
</code></pre><p>On the other hand, you&#39;ll need to rework the Door to implement ISwitchable:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Door : MonoBehaviour, ISwitchable
{
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> isActive;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsActive =&gt; isActive;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Activate</span><span class="hljs-params">()</span>
 </span>{
 isActive = <span class="hljs-literal">true</span>;
 Debug.Log(<span class="hljs-string">"The door is open."</span>);
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deactivate</span><span class="hljs-params">()</span>
 </span>{
 isActive = <span class="hljs-literal">false</span>;
 Debug.Log(<span class="hljs-string">"The door is closed."</span>);
 }
}
</code></pre><p>Now you&#39;ve inverted the dependency. The interface creates an abstraction in between them rather than hardwiring the switch to the door exclusively. The Switch no longer depends directly on the door-specific methods (Open and Close). Instead it uses the ISwitchable&#39;s Activate and Deactivate.</p>
<p>This small but significant change promotes reusability. Whereas Switch would only work with a Door previously, now it works with anything that implements ISwitchable.</p>
<p><span id="page-29-0"></span>This enables you to make more classes that the Switch can activate. The highlevel Switch will work, whether it&#39;s a trap door or a laser beam. It just needs a compatible client that implements ISwitchable.</p>
<p><img src="_page_29_Figure_1.jpeg" alt=""></p>
<p>The Switch can now activate any ISwitchable object.</p>
<p>Like the rest of SOLID, the dependency inversion principle asks you to examine how you normally set up relationships between your classes. Conveniently scale your project with loose coupling.</p>
<p><img src="_page_29_Figure_4.jpeg" alt=""></p>
<p>You can&#39;t instantiate an abstract class directly. Instead you&#39;ll need to derive a concrete class.</p>
<p>In the preceding example, an abstract class could achieve the same dependency inversion, just with a different approach. So rather than use an interface, derive a concrete class (e.g., Light or Door) from an abstract class called Switchable.</p>
<p><img src="_page_30_Figure_2.jpeg" alt=""></p>
<p>Using abstract classes</p>
<p>Inheritance defines an &quot;is a&quot; relationship. Shown in the diagram above are all &quot;switchable&quot; things that can turn on and off.</p>
<p>The advantage of abstract classes is they can have fields and constants as well as static members. They can also apply more restricted access modifiers, like protected and private. Unlike interfaces, abstract classes let you implement logic that enables you to share core functionality between your concrete classes.</p>
<p>Inheritance works well until you want to create a derived class that has characteristics of two different base classes. In C#, you can&#39;t inherit from more than one base class.</p>
<p><span id="page-31-0"></span><img src="_page_31_Figure_0.jpeg" alt=""></p>
<p>Choosing between base classes</p>
<p>If you had another abstract class for all Robots in your game, then it&#39;s harder to decide what to derive from. Do you use the Robot or Switchable base class?</p>
<h4 id="-interfaces-"><strong>Interfaces</strong></h4>
<p>As seen in the interface segregation principle, interfaces give you more flexibility when something doesn&#39;t fit neatly into the paradigm of inheritance. You can pick and choose more easily with a &quot;has a&quot; relationship.</p>
<p>However, interfaces only contain declarations of their members. A class that actually implements the interface will be responsible for fleshing out the specific logic.</p>
<p>Thus, it&#39;s not always an either-or decision. Use abstract classes to define the base functionality where you want to share code. Use interfaces to define peripheral abilities where you need flexibility.</p>
<p><img src="_page_32_Figure_0.jpeg" alt=""></p>
<p><img src="_page_32_Figure_1.jpeg" alt=""></p>
<p>The NPC Robot using both</p>
<p>Keep in mind the following differences between abstract classes and interfaces.</p>
<table>
<thead>
<tr>
<th>Abstract class</th>
<th>Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fully or partially implements<br>methods</td>
<td>Declares methods but can&#39;t<br>implement them</td>
</tr>
<tr>
<td>Declares/uses variables and fields</td>
<td>Declares only methods and<br>properties (but not fields)</td>
</tr>
<tr>
<td>Has static members</td>
<td>Can&#39;t declare/use static members</td>
</tr>
<tr>
<td>Uses constructors</td>
<td>Can&#39;t use constructors</td>
</tr>
<tr>
<td>Uses all access modifiers<br>(protected, private, etc.)</td>
<td>Can&#39;t use access modifiers (all<br>members are implicitly public)</td>
</tr>
</tbody>
</table>
<p>Remember: A class can inherit from at most one abstract class, but it can implement multiple interfaces.</p>
<h4 id="-span-id-page-33-0-span-a-solid-understanding"><span id="page-33-0"></span>A SOLID understanding</h4>
<p>Getting to know the SOLID principles is a matter of daily practice. Think of them as five basic rules to always keep in mind while coding. Here&#39;s a handy recap:</p>
<ul>
<li><strong>Single responsibility</strong>: Make sure classes only do one thing and have only one reason to change.</li>
<li><strong>Open-closed</strong>: You should be able to extend the functionality of a class without changing how it already works.</li>
<li><strong>Liskov substitution</strong>: Subclasses should be substitutable for their base classes.</li>
<li><strong>Interface segregation</strong>: Keep your interfaces short with few methods. Clients only implement what they need.</li>
<li><strong>Dependency inversion</strong>: Depend on abstractions. Don&#39;t depend directly from one concrete class to another.</li>
</ul>
<p>The SOLID principles are guidelines to help you write cleaner code so that it&#39;s more efficient to maintain and extend. SOLID principles have dominated software design for nearly two decades at the enterprise level because they&#39;re well-suited for large applications that must scale.</p>
<p>In some cases, adhering to SOLID can result in additional work up front. You might need to refactor some of your functionality into abstractions or interfaces. However, there is often a payoff in long-term savings.</p>
<p>Determine for yourself how strictly you will apply the principles to your projects; they&#39;re not absolutes. There are nuances, and numerous ways to implement each one that are not covered here. Remember: the thinking behind the principle is more important than any specific syntax.</p>
<p>When unsure about how to use them, refer back to the KISS principle. Keep it simple, and don&#39;t try to force the principles into your scripts just for the sake of doing it. Let them organically work themselves into place through necessity.</p>
<p>For more information, be sure to check out the <a href="https://www.youtube.com/watch?v=eIf3-aDTOOA?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Unity SOLID presentation</a> from Unite Austin.</p>
<h1 id="-span-id-page-34-0-span-d-e-s-i-g-n-p-a-t-t-e-r-n-s-f-o-r-game-development"><span id="page-34-0"></span>D E S I G N P A T T E R N S F O R GAME DEVELOPMENT</h1>
<p><span id="page-35-0"></span>Once you understand the SOLID principles, you&#39;ll want to dive deeper into design patterns.</p>
<p>Design patterns let you repurpose well-known solutions for everyday software problems. A pattern, however, isn&#39;t an off-the-shelf library or framework. Nor is it an algorithm, which is a specific set of steps to achieve a result.</p>
<p>Instead, think of a design pattern more like a blueprint. It&#39;s a general plan that leaves the actual construction up to you. Two programs can follow the same pattern but have very different code.</p>
<p>When developers encounter the same problem in the wild, many of them will inevitably come up with similar solutions. Once such a solution becomes repeated enough, someone might &quot;discover&quot; a pattern and formally give it a name.</p>
<h4 id="the-gang-of-four">The Gang of Four</h4>
<p>Many of today&#39;s software design patterns stem from the seminal work, <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. This book describes 23 such patterns identified in a variety of day-to-day applications.</p>
<p>The original authors are often referred to as the &quot;Gang of Four&quot; (GoF), and you&#39;ll also hear the original patterns dubbed the GoF patterns. While the examples cited are mostly in C++ (and Smalltalk), you can apply their ideas to any objectoriented language, such as C#.</p>
<p>Since the Gang of Four originally published <em>Design Patterns</em> in 1994, developers have discovered dozens more object-oriented patterns in a variety of fields. Many engineering specialities have well-established patterns. Game development is no different.</p>
<h4 id="learning-design-patterns">Learning design patterns</h4>
<p>While you can work as a game programmer without studying design patterns, learning them will only help you become a better developer. After all, design patterns are labeled as such because they&#39;re common solutions to well-known problems.</p>
<p>Software engineers rediscover them all the time in the normal course of development. You may have already implemented some of these patterns unwittingly.</p>
<p>Train yourself to look for them. Doing this can help you:</p>
<p>— <strong>Learn object-oriented programming:</strong> Design patterns aren&#39;t secrets buried in an esoteric StackOverflow post. They are common ways to overcome everyday hurdles in development. They can inform you how many other developers approached the same issue. Remember, even if you aren&#39;t using patterns, someone else is.</p>
<ul>
<li><span id="page-36-0"></span>— <strong>Talk to other developers:</strong> Patterns can serve as a shorthand when trying to communicate as a team. Mention the &quot;command pattern&quot; or &quot;object pool&quot; and experienced Unity developers will know exactly what you&#39;re trying to implement.</li>
<li><strong>Explore new frameworks:</strong> When you import a built-in package or something from the Asset Store, inevitably you&#39;ll stumble onto one or more patterns discussed here. Recognizing design patterns will help you understand how a new framework works and the thought process involved in its creation.</li>
</ul>
<p>Of course, not all design patterns apply to every game application. Don&#39;t go looking for them with <a href="https://en.wikipedia.org/wiki/Law_of_the_instrument">Maslow&#39;s hammer;</a> otherwise, you might only find nails.</p>
<p>Like any other tool, a design pattern&#39;s usefulness depends on context. Each one provides a benefit in certain situations and also comes with its share of drawbacks. Every decision in software development comes with compromises.</p>
<p>Are you generating a lot of GameObjects on the fly? Does it impact your performance? Can restructuring your code fix that?</p>
<p>Be aware of these design patterns and when the time is right, pull them from your gamedev bag of tricks to solve the problem at hand.</p>
<h3 id="-further-reading-"><strong>Further reading</strong></h3>
<p>In addition to the Gang of Four&#39;s <em><a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable</a>  <a href="https://en.wikipedia.org/wiki/Design_Patterns">Object-Oriented Software</a></em>, another standout volume is <em><a href="https://gameprogrammingpatterns.com/">Game Programming</a>  <a href="https://gameprogrammingpatterns.com/">Patterns</a></em> by Robert Nystrom. The author details a variety of software patterns in a no-nonsense manner. The web-based edition is available for free at <a href="https://gameprogrammingpatterns.com/">gameprogrammingpatterns.com.</a></p>
<h4 id="patterns-within-unity">Patterns within Unity</h4>
<p>Unity already implements several established gamedev patterns, saving you the trouble of writing them yourself. These include:</p>
<p>— <strong>Game loop:</strong> At the core of all games is an infinite loop that must function independently of clock speed, since the hardware that powers a game application can vary greatly. To account for computers of different speeds, game developers often need to use a fixed timestep (with a set framesper-second) and a variable timestep where the engine measures how much time has passed since the previous frame.</p>
<p>Unity takes care of this, so you don&#39;t have to implement it yourself. You only need to manage gameplay using MonoBehaviour methods like Update, LateUpdate, and FixedUpdate.</p>
<ul>
<li><strong>Update:</strong> In your game application, you&#39;ll often update each object&#39;s behavior one frame at a time. While you can manually recreate this in Unity, the MonoBehaviour class does this automatically. Simply use the appropriate Update, LateUpdate, or FixedUpdate methods to modify your GameObjects and components to one tick of the game clock.</li>
<li><strong>Prototype:</strong> Often you need to copy objects without affecting the original. This creational pattern solves the problem of duplicating and cloning an object to make other objects similar to itself. This way you avoid defining a separate class to spawn every type of object in your game.</li>
</ul>
<p>Unity&#39;s <a href="https://docs.unity3d.com/Manual/Prefabs.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Prefab</a> system implements a form of prototyping for GameObjects. This allows you to duplicate a template object, complete with its components. Override specific properties to create <a href="https://docs.unity3d.com/Manual/PrefabVariants.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Prefab Variants</a> or <a href="https://docs.unity3d.com/Manual/NestedPrefabs.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">nest</a>  <a href="https://docs.unity3d.com/Manual/NestedPrefabs.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Prefabs</a> inside other Prefabs to create hierarchies. Use a special <a href="https://docs.unity3d.com/Manual/EditingInPrefabMode.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Prefab editing mode</a> to edit Prefabs in isolation or in context.</p>
<p>— <strong>Component:</strong> Most people working in Unity know this pattern. Instead of creating large classes with multiple responsibilities, build smaller components that each do one thing.</p>
<p>If you use composition to pick and choose components, you combine them for complex behavior. Add Rigidbody and Collider components for physics. Add a MeshFilter and MeshRenderer for 3D geometry. Each GameObject is only as rich and unique as its collection of components.</p>
<p>Of course, Unity can&#39;t do everything for you. Inevitably you&#39;ll need other patterns that aren&#39;t built-in. Let&#39;s explore a few of these in the next chapters.</p>
<h3 id="-span-id-page-38-0-span-factory-pat-tern"><span id="page-38-0"></span>FACTORY PAT TERN</h3>
<p><span id="page-39-0"></span><img src="_page_39_Figure_0.jpeg" alt=""></p>
<p>A factory can spawn one or more products.</p>
<p>Sometimes it&#39;s helpful to have a special object that creates other objects. Many games spawn a variety of things over the course of gameplay, and you often don&#39;t know what you need at runtime until you actually need it.</p>
<p>The factory pattern designates a special object called – you guessed it – a factory for this purpose. On one level, it encapsulates many of the details involved in spawning its &quot;products.&quot; The immediate benefit is to declutter your code.</p>
<p>However, if each product follows a common interface or base class, you can take this a step further and make it contain more of its own construction logic, hiding it away from the factory itself. Creating new objects thus becomes more extensible.</p>
<p>You can also subclass the factory to make multiple factories dedicated to specific products. Doing this helps generate enemies, obstacles, or anything else at runtime.</p>
<h4 id="example-a-simple-factory">Example: A simple factory</h4>
<p>Imagine you want to create a factory pattern to instantiate items for a game level. You can use Prefabs to create GameObjects, but you might also want to run some custom behavior when creating each instance.</p>
<p>Rather than using if statements or a switch to maintain this logic, create an interface called IProduct and an abstract class called Factory:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IProduct</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> ProductName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span>(<span class="hljs-params"></span>)</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> : <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IProduct <span class="hljs-title">GetProduct</span>(<span class="hljs-params">Vector3 position</span>)</span>;
 <span class="hljs-comment">// shared method with all factories</span>
 …
}
</code></pre><p>Products need to follow a specific template for their methods, but they don&#39;t otherwise share any functionality. Hence, you define the IProduct interface.</p>
<p>Factories might need some shared common functionality, so this sample uses abstract classes. Just be mindful of Liskov substitution from the SOLID principles when using subclasses.</p>
<p>They can result in a structure like this:</p>
<p><img src="_page_40_Figure_4.jpeg" alt=""></p>
<p>Using an interface to define shared properties and logic between your products</p>
<p>The IProduct interface defines what is common between your products. In this case, you simply have a ProductName property and any logic the product runs on Initialize.</p>
<p>You can then define as many products as you need (ProductA, ProductB, etc.) so long as they follow the IProduct interface.</p>
<p>The base class, Factory, has a GetProduct method that returns an IProduct. It&#39;s abstract, so you can&#39;t make instances of Factory directly. You derive a couple of concrete subclasses (ConcreteFactoryA and ConcreteFactoryB), which will actually get the different products.</p>
<p>GetProduct in this example takes a Vector3 position so that you can instantiate a Prefab GameObject more easily at a specific location. A field in each concrete factory also stores the corresponding template Prefab.</p>
<p>Here&#39;s the sample ProductA and ConcreteFactoryA.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IProduct</span>
</span>{
 [SerializeField] <span class="hljs-keyword">private</span> string productName = <span class="hljs-string">"ProductA"</span>;
 <span class="hljs-keyword">public</span> string ProductName { <span class="hljs-keyword">get</span> =&gt; productName; <span class="hljs-keyword">set</span> =&gt; productName 
= value ; }
 <span class="hljs-keyword">private</span> ParticleSystem particleSystem;
 <span class="hljs-keyword">public</span> void Initialize()
 {
 <span class="hljs-comment">// any unique logic to this product</span>
 gameObject.name = productName;
 particleSystem = GetComponentInChildren&lt;ParticleSystem&gt;();
 particleSystem?.Stop();
 particleSystem?.Play();
 }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactoryA</span> : <span class="hljs-title">Factory</span>
</span>{
 [SerializeField] <span class="hljs-keyword">private</span> ProductA productPrefab;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IProduct GetProduct(Vector3 position)
 {
 <span class="hljs-comment">// create a Prefab instance and get the product component</span>
 GameObject instance = Instantiate(productPrefab.gameObject, 
position, Quaternion.identity);
 ProductA <span class="hljs-keyword">new</span><span class="hljs-type">Product</span> = instance.GetComponent&lt;ProductA&gt;();
 <span class="hljs-comment">// each product contains its own logic</span>
 <span class="hljs-keyword">new</span><span class="hljs-type">Product</span>.Initialize();
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Product</span>;
 }
}
</code></pre><p><span id="page-42-0"></span>Here, you&#39;ve made the product classes MonoBehaviours that implement IProduct take advantage of Prefabs in the factory.</p>
<p>Note how each product can have its own version of Initialize. The example ProductA Prefab contains a ParticleSystem, which plays when the ConcreteFactoryA instantiates a copy. The factory itself does not contain any specific logic for triggering the particles; it only invokes the Initialize method, which is common to all products.</p>
<p>Explore the sample project to see how the ClickToCreate component switches between factories to create ProductA and ProductB, which have different behaviors. ProductB plays a sound when it spawns, while ProductA sets off a particle effect.</p>
<h4 id="pros-and-cons">Pros and cons</h4>
<p>You&#39;ll benefit the most from the factory pattern when setting up many products. Defining new product types in your application doesn&#39;t change your existing ones or require you to modify previous code.</p>
<p>Separating each product&#39;s internal logic into its own class keeps the factory code relatively short. Each factory only knows to invoke Initialize on each product without being privy to the underlying details.</p>
<p>The downside is that you create a number of classes and subclasses to implement the pattern. Like the other patterns, this introduces a bit of overhead, which may be unnecessary if you don&#39;t have a large variety of products.</p>
<p><img src="_page_42_Picture_7.jpeg" alt=""></p>
<p>One product plays a sound, while another plays particles. Both use the same interface.</p>
<h4 id="-span-id-page-43-0-span-improvements"><span id="page-43-0"></span>Improvements</h4>
<p>The implementation of the factory can vary widely from what&#39;s shown here. Consider the following adjustments when building your own factory pattern:</p>
<ul>
<li><strong>Use a dictionary to search for products:</strong> You might want to store your products as key-value pairs in a dictionary. Use a unique string identifier (e.g., the Name or some ID) as the key and the type as a value. This can make retrieving products and/or their corresponding factories more convenient.</li>
<li><strong>Make the factory (or a factory manager) static:</strong> This makes it easier to use but requires additional setup. Static classes won&#39;t appear in the Inspector, so you will need to make your collection of products static as well.</li>
<li><strong>Apply it to non-GameObjects and non-MonoBehaviours:</strong> Don&#39;t limit yourself to Prefabs or other Unity-specific components. The factory pattern can work with any C# object.</li>
<li><strong>Combine with the object pool pattern:</strong> Factories don&#39;t necessarily need to instantiate or create new objects. They can also retrieve existing ones in the hierarchy. If you are instantiating many objects at once, (e.g., projectiles from a weapon), use the <a href="#page-44-0">object pool pattern</a> for more optimized memory management.</li>
</ul>
<p>Factories can spawn any gameplay element on an as-needed basis. Note, however, that creating products is often not their only purpose. You might be using the factory pattern as part of another larger task (e.g., setting up UI elements in a dialog box of parts of a game level).</p>
<h1 id="-span-id-page-44-0-span-object-pool"><span id="page-44-0"></span>OBJECT POOL</h1>
<p><span id="page-45-0"></span>Object pooling is an optimization technique to relieve the CPU when creating and destroying a lot of GameObjects.</p>
<p>The object pool pattern uses a set of initialized objects kept ready and waiting in a deactivated &quot;pool.&quot; When you need an object, your application doesn&#39;t instantiate it. Instead you request the GameObject from the pool and enable it.</p>
<p>When done using it, you deactivate the object and return it to the pool instead of destroying it.</p>
<p>Object pools can reduce stuttering that may result from garbage collection spikes. GC spikes often accompany creating or destroying a large number of objects due to the allocation of memory. You can pre-instantiate your object pool at an opportune time, such as during a loading screen, when the user won&#39;t notice the stutter.</p>
<p><img src="_page_45_Picture_4.jpeg" alt=""></p>
<p>An object pool can help you shoot bullets without gameplay stutter.</p>
<h4 id="example-simple-pool-system">Example: Simple pool system</h4>
<p>Consider a simple pooling system with two defined MonoBehaviours:</p>
<ul>
<li>An ObjectPool that holds the collection of GameObjects to draw from</li>
<li>A PooledObject component added to the Prefab. This helps each cloned item keep a reference to the pool</li>
</ul>
<p>In ObjectPool, you set up fields describing the size of the pool, the PooledObject Prefab that you want to store, and a collection that will form the pool itself (a stack in this example).</p>
<pre><code>public class ObjectPool<span class="hljs-keyword"> :</span> MonoBehaviour
{
 [SerializeField]<span class="hljs-keyword"> private</span> uint initPoolSize;
 [SerializeField]<span class="hljs-keyword"> private</span> PooledObject objectToPool;
 // store the pooled objects in a collection
<span class="hljs-keyword"> private</span> Stack&lt;PooledObject&gt; stack;
<span class="hljs-keyword"> private</span> void Start()
 {
 SetupPool();
 }
 // creates the pool (invoke when the lag is<span class="hljs-built_in"> not </span>noticeable)
<span class="hljs-keyword"> private</span> void SetupPool()
 {
 stack =<span class="hljs-built_in"> new </span>Stack&lt;PooledObject&gt;();
 PooledObject<span class="hljs-built_in"> instance </span>= null;
 for (int i = 0; i &lt; initPoolSize; i++)
 {
<span class="hljs-built_in"> instance </span>= Instantiate(objectToPool);
 instance.Pool = this;
 instance.gameObject.SetActive(false);
 stack.Push(instance);
 }
 }
</code></pre><p>The SetupPool method populates the object pool. Create a new stack of PooledObjects and then instantiate copies of the objectToPool to fill it with initPoolSize elements. Invoke SetupPool in Start to make sure that it runs once during gameplay.</p>
<p>You&#39;ll also need methods to retrieve a pooled item (GetPooledObject) and return one to the pool (ReturnToPool):</p>
<pre><code><span class="hljs-comment">// returns the first active GameObject from the pool</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> PooledObject <span class="hljs-title">GetPooledObject</span><span class="hljs-params">()</span>
 </span>{
 <span class="hljs-comment">// if the pool is not large enough, instantiate a new PooledOb-</span>
<span class="hljs-function">jects
 <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-built_in">stack</span>.Count == <span class="hljs-number">0</span>)</span>
 </span>{
 PooledObject newInstance = Instantiate(objectToPool);
 newInstance.Pool = <span class="hljs-keyword">this</span>;
 <span class="hljs-keyword">return</span> newInstance;
 }
 <span class="hljs-comment">// otherwise, just grab the next one from the list</span>
 PooledObject nextInstance = <span class="hljs-built_in">stack</span>.Pop();
 nextInstance.gameObject.SetActive(<span class="hljs-literal">true</span>);
 <span class="hljs-keyword">return</span> nextInstance;
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReturnToPool</span><span class="hljs-params">(PooledObject pooledObject)</span>
 </span>{
 <span class="hljs-built_in">stack</span>.Push(pooledObject);
 pooledObject.gameObject.SetActive(<span class="hljs-literal">false</span>);
 }
}
</code></pre><p>GetPooledObject creates a new PooledObject only if the pool is empty. Otherwise, it simply returns the next available element. If the pool size is sufficient, most of the time you should only get a reference to an existing GameObject.</p>
<p>The client calling GetPooledObject then needs to move/rotate the pooled object into place.</p>
<p>Each pooled element will have a small PooledObject component, just to reference the ObjectPool:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PooledObject</span> : <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-keyword">private</span> ObjectPool pool;
 <span class="hljs-keyword">public</span> ObjectPool Pool { <span class="hljs-keyword">get</span> =&gt; pool; <span class="hljs-keyword">set</span> =&gt; pool = <span class="hljs-keyword">value</span>; }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Release</span>(<span class="hljs-params"></span>)
 </span>{
 pool.ReturnToPool(<span class="hljs-keyword">this</span>);
 }
}
</code></pre><p>Calling Release disables the GameObject and returns it to the pool queue.</p>
<p>The accompanying project shows a basic usage example. Here, an ExampleGun script is attached to a GameObject. That stores a reference to the object pool. When the user shoots, the weapon script invokes its GetPooledObject method instead of calling Object.Instantiate.</p>
<p>On the projectile itself is an ExampleProjectile script and a PooledObject script. The ExampleProjectile has a Deactivate method to disable each fired bullet GameObject after a few seconds, returning it to the available pool.</p>
<p><img src="_page_48_Figure_3.jpeg" alt=""></p>
<p>Disable and reuse pooled objects</p>
<p>This way, you can appear to fire hundreds of bullets offscreen when in reality, you simply disable and recycle them. Just make sure your pool size is large enough to show the concurrently active objects.</p>
<p>If you need to exceed the pool size, the pool can instantiate extra objects. However, most of the time it pulls from the existing inactive objects.</p>
<p>If you&#39;ve used Unity&#39;s ParticleSystem, then you have firsthand experience with an object pool. The ParticleSystem component contains a setting for the max number of particles. This simply recycles available particles, preventing the effect from exceeding a maximum number. The object pool works similarly, but with any GameObject of your choosing.</p>
<h4 id="-span-id-page-49-0-span-improvements"><span id="page-49-0"></span>Improvements</h4>
<p>The example above is a simple one. When deploying an object pool for actual projects, consider the following upgrades:</p>
<ul>
<li><strong>Make it static or a singleton:</strong> If you need to generate pooled objects from a variety of sources, consider making the object pool static. This makes it accessible anywhere in your application but precludes use of the Inspector. Alternatively, combine the object pool pattern with the <a href="#page-52-0">singleton</a>  <a href="#page-52-0">pattern</a> to make it globally accessible for ease of use.</li>
<li><strong>Use a dictionary to manage multiple pools:</strong> If you have a number of different Prefabs that you want to pool, store them in separate pools and store a key-value pair so you know which pool to query (the <a href="https://docs.unity3d.com/ScriptReference/Object.GetInstanceID.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">InstanceID</a> of the Prefab can work as the unique key).</li>
<li><strong>Remove unused GameObjects creatively:</strong> Part of utilizing an object pool effectively is hiding unused objects and returning them to the pool. Use every opportunity to deactivate a pooled object (e.g., offscreen, hidden by explosions, etc.)</li>
<li><strong>Check for errors:</strong> Avoid releasing an object that is already in the pool. Otherwise, it might result in an error at runtime.</li>
<li><strong>Add a maximum size/cap:</strong> Lots of pooled objects consume memory. You may need to remove objects that exceed a certain limit so that the pool doesn&#39;t use too many resources.</li>
</ul>
<p>How you use object pools will vary by application. This pattern commonly appears when a gun or weapon needs to fire multiple projectiles like in a bullet hell shooter.</p>
<p>Every time you instantiate a large number of objects, you run the risk of causing a small pause from a garbage-collection spike. An object pool alleviates this issue to keep your gameplay smooth.</p>
<p>If you&#39;re using a version of Unity from 2021 and above, it includes a built-in object pooling system, so there&#39;s no need to create your own PooledObject or ObjectPool classes like in the previous example.</p>
<h4 id="unityengine-pool">UnityEngine.Pool</h4>
<p>The object pool pattern is so ubiquitous that Unity 2021 now supports its own <a href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UnityEngine.Pool API.</a> This gives you a stack-based ObjectPool to track your objects with the object pool pattern. Depending on your needs, you can also use a CollectionPool (List, HashSet, Dictionary, etc.)</p>
<p>In the sample project (see the scene), you no longer need the custom pool components. Instead, update the gun script with a using UnityEngine.Pool; line at the top. This allows you to create a projectile pool with the built-in ObjectPool:</p>
<pre><code><span class="hljs-keyword">using</span> UnityEngine.Pool;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RevisedGun</span> : <span class="hljs-title">MonoBehaviour</span>
{
 …
 <span class="hljs-comment">// stack-based ObjectPool available with Unity 2021 and above</span>
 <span class="hljs-keyword">private</span> IObjectPool&lt;RevisedProjectile&gt; objectPool;
 <span class="hljs-comment">// throw an exception if we try to return an existing item, already </span>
<span class="hljs-keyword">in</span> the pool
 [SerializeField] <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> collectionCheck = <span class="hljs-literal">true</span>;
 <span class="hljs-comment">// extra options to control the pool capacity and maximum size</span>
 [SerializeField] <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> defaultCapacity = <span class="hljs-number">20</span>;
 [SerializeField] <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">100</span>;
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)
 </span>{
 objectPool = <span class="hljs-keyword">new</span> ObjectPool&lt;RevisedProjectile&gt;(CreateProjec-
tile,
 OnGetFromPool, OnReleaseToPool, OnDestroyPooledObject,
 collectionCheck, defaultCapacity, maxSize);
 }
 <span class="hljs-comment">// invoked when creating an item to populate the object pool</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> RevisedProjectile <span class="hljs-title">CreateProjectile</span>(<span class="hljs-params"></span>)
 </span>{
 RevisedProjectile projectileInstance = Instantiate(projec-
tilePrefab);
 projectileInstance.ObjectPool = objectPool;
 <span class="hljs-keyword">return</span> projectileInstance;
 }
 <span class="hljs-comment">// invoked when returning an item to the object pool</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnReleaseToPool</span>(<span class="hljs-params">RevisedProjectile pooledObject</span>)
 </span>{
 pooledObject.gameObject.SetActive(<span class="hljs-literal">false</span>);
 }
 <span class="hljs-comment">// invoked when retrieving the next item from the object pool</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGetFromPool</span>(<span class="hljs-params">RevisedProjectile pooledObject</span>)
 </span>{
 pooledObject.gameObject.SetActive(<span class="hljs-literal">true</span>);
 }
 <span class="hljs-comment">// invoked when we exceed the maximum number of pooled items (i.e. </span>
destroy the pooled <span class="hljs-keyword">object</span>)
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroyPooledObject</span>(<span class="hljs-params">RevisedProjectile pooledObject</span>)
 </span>{
 Destroy(pooledObject.gameObject);
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>(<span class="hljs-params"></span>)
 </span>{
 …
 }
}
</code></pre><p>Much of the script works for the original ExampleGun script. The <a href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1-ctor.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">ObjectPool</a> constructor, however, now includes the helpful ability to set up some logic when:</p>
<ul>
<li>First creating a pooled item to populate the pool</li>
<li>Taking an item from the pool</li>
<li>Returning an item to the pool</li>
<li>Destroying a pooled object (e.g., if you hit a maximum limit)</li>
</ul>
<p>You must then define some corresponding methods to pass into the constructor.</p>
<p>Note how the built-in ObjectPool also includes options for a default pool size and maximum pool size. Items exceeding the max pool size trigger an action to self-destruct, keeping memory usage in check.</p>
<p>The projectile script gets a small modification to keep a reference to the ObjectPool. This makes releasing the object back to the pool a little more convenient.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RevisedProjectile</span> : <span class="hljs-title">MonoBehaviour</span>
{
 …
 <span class="hljs-keyword">private</span> IObjectPool&lt;RevisedProjectile&gt; objectPool;
 <span class="hljs-comment">// public property to give the projectile a reference to its Ob-</span>
jectPool
 <span class="hljs-keyword">public</span> IObjectPool&lt;RevisedProjectile&gt; ObjectPool { <span class="hljs-keyword">set</span> =&gt; <span class="hljs-keyword">object</span>-
Pool = <span class="hljs-keyword">value</span>; }

 …
}
</code></pre><p>The <a href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UnityEngine.Pool API</a> makes setting up object pools faster, now that you don&#39;t have to rebuild the pattern from scratch. That&#39;s one less wheel to reinvent.</p>
<h3 id="-span-id-page-52-0-span-s-i-n-g-l-e-t-o-n-pat-tern"><span id="page-52-0"></span>S I N G L E T O N PAT TERN</h3>
<p>Singletons get a bad rap. If you&#39;re new to Unity development, the singleton is likely one of the first recognizable patterns that you will encounter in the wild. It&#39;s also one of the most maligned design patterns.</p>
<p>According to the original Gang of Four, the singleton pattern:</p>
<ul>
<li>Ensures that a class can only instantiate one instance of itself</li>
<li>Gives easy global access to that single instance</li>
</ul>
<p>This is useful if you need to have exactly one object that coordinates actions across the entire scene. For example, you might want exactly one game manager in your scene to direct the main game loop. You also probably only want one file manager writing to your filesystem at a time. Central, managerlevel objects like these tend to be good candidates for the singleton pattern.</p>
<p><img src="_page_53_Figure_5.jpeg" alt=""></p>
<p>The SimpleSingleton destroys any instances beyond the first.</p>
<p>In <em>Game Programming Patterns</em>, it says that singletons do more harm than good and lists it as an anti-pattern. This poor reputation is because the pattern&#39;s ease of use lends itself to abuse. Developers tend to apply singletons in inappropriate situations, introducing unnecessary global states or dependencies.</p>
<p>Let&#39;s examine how to build a singleton in Unity and weigh its strengths and weaknesses. Then you can decide whether it&#39;s worth incorporating into your application.</p>
<h4 id="-span-id-page-54-0-span-example-simple-singleton"><span id="page-54-0"></span>Example: Simple singleton</h4>
<p>One of the simplest singletons might look like this:</p>
<pre><code><span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleSingleton</span> : <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SimpleSingleton Instance;
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (Instance == <span class="hljs-literal">null</span>)
 {
 Instance = <span class="hljs-keyword">this</span>; 
 }
 <span class="hljs-keyword">else</span>
 {
 Destroy(gameObject); 
 }
 }
}
</code></pre><p>The public static Instance will hold the one instance of Singleton in the scene.</p>
<p>In the Awake method, check if it&#39;s already set. If Instance is currently null, then Instance gets set to this specific object. This must be the first singleton in the scene.</p>
<p>Otherwise, this instance must be a duplicate; you call Destroy(gameObject) to guarantee your singleton only has one such component in the scene.</p>
<p>If you attach the script to more than one GameObject in the hierarchy at runtime, the logic in Awake will keep the first object and then discard the rest.</p>
<p><span id="page-55-0"></span><img src="_page_55_Figure_0.jpeg" alt=""></p>
<p>The Instance field is public and static. Any component has global access to the lone singleton from anywhere in the scene.</p>
<h4 id="persistence-and-lazy-instantiation">Persistence and lazy instantiation</h4>
<p>The SimpleSingleton works as written. However, it does suffer from two issues:</p>
<ul>
<li>Loading a new scene destroys the GameObject.</li>
<li>You need to set up the singleton in the hierarchy before using it.</li>
</ul>
<p>Because the singleton often serves as an omnipresent manager script, you can benefit from making it persistent using a DontDestroyOnLoad.</p>
<p>Further, you can use <a href="https://en.wikipedia.org/wiki/Lazy_initialization">lazy instantiation</a> to build the singleton automatically when you first need it. You only need some logic to create a GameObject and then add the appropriate Singleton component.</p>
<p>The improved singleton looks something like this:</p>
<pre><code><span class="hljs-keyword"> public</span> class Singleton<span class="hljs-keyword"> :</span> MonoBehaviour
 {
<span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton instance;
<span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> Singleton Instance
 {
 get
 {
<span class="hljs-built_in"> if </span>(instance == null)
 {
 SetupInstance();
 }
<span class="hljs-built_in"> return </span>instance;
 }
 }
<span class="hljs-keyword"> private</span> void Awake()
 {
<span class="hljs-built_in"> if </span>(instance == null)
 {
<span class="hljs-built_in"> instance </span>= this;
 DontDestroyOnLoad(this.gameObject);
 }
 else
 {
 Destroy(gameObject);
 }
 }
<span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> void SetupInstance()
 {
<span class="hljs-built_in"> instance </span>= FindObjectOfType&lt;Singleton&gt;();
<span class="hljs-built_in"> if </span>(instance == null)
 {
 GameObject gameObj =<span class="hljs-built_in"> new </span>GameObject();
 gameObj.name = <span class="hljs-string">"Singleton"</span>;
<span class="hljs-built_in"> instance </span>= gameObj.AddComponent&lt;Singleton&gt;();
 DontDestroyOnLoad(gameObj);
 }
 }
</code></pre><p>Instance is now a public property referring to the private instance backing field. The first time you refer to the singleton, check for the existence of Instance in the getting. If it doesn&#39;t exist, the SetupInstance method creates a GameObject with the appropriate component.</p>
<p>DontDestroyOnLoad(gameObject) prevents a scene load from clearing the singleton from the hierarchy. The singleton instance is now persistent, staying active even if you change scenes in your game.</p>
<h4 id="-span-id-page-57-0-span-using-generics"><span id="page-57-0"></span>Using generics</h4>
<p>Neither version of the script addresses how to create different singletons within the same scene. For example, if you want a singleton that behaves as an AudioManager and another singleton as a GameManager, they can&#39;t coexist right now. You&#39;ll need to duplicate the relevant code and paste the logic into each class.</p>
<p>Instead, make a generic version of the script like so:</p>
<pre><code>public class Singleton&lt;T&gt;<span class="hljs-keyword"> :</span> MonoBehaviour where T<span class="hljs-keyword"> :</span> Component
{
<span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> T instance;
<span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> T Instance
 {
 get
 {
<span class="hljs-built_in"> if </span>(instance == null)
 {
<span class="hljs-built_in"> instance </span>= (T)FindObjectOfType(typeof(T));
<span class="hljs-built_in"> if </span>(instance == null)
 {
 SetupInstance();
 }
 }
<span class="hljs-built_in"> return </span>instance;
 }
 }
<span class="hljs-keyword"> public</span> virtual void Awake()
 {
 RemoveDuplicates();
 }
<span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> void SetupInstance()
 {
<span class="hljs-built_in"> instance </span>= (T)FindObjectOfType(typeof(T));
<span class="hljs-built_in"> if </span>(instance == null)
 {
 GameObject gameObj =<span class="hljs-built_in"> new </span>GameObject();
 gameObj.name = typeof(T).Name;
<span class="hljs-built_in"> instance </span>= gameObj.AddComponent&lt;T&gt;();
 DontDestroyOnLoad(gameObj);
 }
 }
<span class="hljs-keyword"> private</span> void RemoveDuplicates()
 {
<span class="hljs-built_in"> if </span>(instance == null)
 {
<span class="hljs-built_in"> instance </span>= this as T;
 DontDestroyOnLoad(gameObject);
 }
 else
 {
 Destroy(gameObject);
 }
 }
}
</code></pre><p><span id="page-58-0"></span>This allows you to turn any class into a singleton. When you declare your class, simply inherit from the generic singleton. For example, you can make a MonoBehaviour called GameManager into a singleton by declaring it like so:</p>
<pre><code>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span>: <span class="hljs-title">Singleton</span>&lt;GameManager&gt;</span>
{
 <span class="hljs-regexp">//</span> ...
}
</code></pre><p>Then you can always refer to the public static GameManager.Instance whenever you need it.</p>
<h4 id="pros-and-cons">Pros and cons</h4>
<p>Singletons are unlike the other patterns in this guide in that they break with SOLID principles in several respects. Many developers dislike them for a variety of reasons:</p>
<ul>
<li><strong>Singletons require global access:</strong> Because you use them as global instances, they can hide many dependencies, making bugs much harder to troubleshoot.</li>
<li><strong>Singletons make testing difficult:</strong> Unit tests must be independent of each other. Because the singleton can change the state of many GameObjects across the scene, they can interfere with your testing.</li>
<li><strong>Singletons encourage tight coupling:</strong> Most of the patterns in this guide attempt to decouple dependencies. Singletons do the opposite. Tight coupling makes refactoring difficult. If you change one component, you can affect any component connected to it, leading to unclean code.</li>
</ul>
<p>The nays against singletons are considerable. If you&#39;re building an enterpriselevel game that you expect to maintain for years to come, you might want to steer clear of singletons.</p>
<p>But many games are not enterprise-level applications. You don&#39;t need to extend them continuously the same way you might for business software.</p>
<p>In fact, singletons offer some benefits that you may find attractive if you&#39;re building a small game that doesn&#39;t need extensibility:</p>
<ul>
<li><strong>Singletons are relatively quick to learn:</strong> The core pattern itself is somewhat straightforward.</li>
<li><strong>Singletons are user-friendly:</strong> To use your singleton from another component, simply reference the public and static instance. The singleton instance is always available on demand from any object in your scene.</li>
<li><strong>Singletons are performant:</strong> Because you always have global access to the static singleton instance, you can avoid caching the results of GetComponent or Find operations, which tend to be slow.</li>
</ul>
<p>In this way, you can make a manager object (e.g., game flow manager or audio manager) that is always accessible from every other GameObject in your scene. Also, if you&#39;ve implemented the object pool, you can design your pooling system as a singleton to make getting pooled objects easier.</p>
<p>If you decide to use singletons in your project, keep them to a minimum. Don&#39;t use them indiscriminately. Reserve the singletons for a handful of scripts that can benefit from global access.</p>
<h3 id="-span-id-page-60-0-span-c-o-m-m-a-n-d-pat-tern"><span id="page-60-0"></span>C O M M A N D PAT TERN</h3>
<p><span id="page-61-0"></span>One of the original Gang of Four patterns, command is useful whenever you want to track a specific series of actions. You&#39;ve likely seen the command pattern at work if you&#39;ve played a game that uses undo/redo functionality or keeps your input history in a list. Imagine a strategy game where the user can plan several turns before actually executing them. That&#39;s the command pattern.</p>
<p>Instead of invoking a method directly, the command pattern allows you to encapsulate one or more method calls as a &quot;command object.&quot;</p>
<p><img src="_page_61_Figure_2.jpeg" alt=""></p>
<p>Storing actions with the command pattern</p>
<p>Storing these command objects in a collection like a queue or a stack allows you to control the timing of their execution. This functions as a small buffer. You can then potentially delay a series of actions for later playback or undo them.</p>
<p>To implement the command pattern, you need a general object that will contain your action. This command object will hold what logic to perform and how to undo it.</p>
<h4 id="the-command-object-and-command-invoker">The command object and command invoker</h4>
<p>There are a number of ways to implement this, but here&#39;s one version that uses an interface:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICommand</span>
{
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"></span>)</span>;
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>(<span class="hljs-params"></span>)</span>;
}
</code></pre><p>In this case, every gameplay action will apply the ICommand interface (you could also implement this with an abstract class).</p>
<p>Each command object will be responsible for its own Execute and Undo methods. Thus, adding more commands to your game won&#39;t affect any existing ones.</p>
<p>You&#39;ll need another class to execute and undo commands. Create a CommandInvoker class. In addition to the ExecuteCommand and UndoCommand methods, it has an undo stack to hold the sequence of command objects.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CommandInvoker</span>
{
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Stack&lt;ICommand&gt; undoStack = <span class="hljs-keyword">new</span> Stack&lt;ICommand&gt;();
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteCommand</span>(<span class="hljs-params">ICommand command</span>)
 </span>{
 command.Execute();
 undoStack.Push(command);
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UndoCommand</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (undoStack.Count &gt; <span class="hljs-number">0</span>)
 {
 ICommand activeCommand = undoStack.Pop();
 activeCommand.Undo();
 }
 }
}
</code></pre><h4 id="example-undoable-movement">Example: Undoable movement</h4>
<p>Let&#39;s imagine you want to move your player around a maze in your application. You could create a PlayerMover responsible for shifting the player&#39;s position:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PlayerMover : MonoBehaviour
{
 [SerializeField] <span class="hljs-keyword">private</span> LayerMask obstacleLayer;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> boardSpacing = <span class="hljs-number">1</span>f;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Move(Vector3 movement)
 {
 transform.<span class="hljs-built_in">position</span> = transform.<span class="hljs-built_in">position</span> + movement;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsValidMove(Vector3 movement)
 {
 <span class="hljs-built_in">return</span> !Physics.Raycast(transform.<span class="hljs-built_in">position</span>, movement, board-
Spacing, obstacleLayer);
 }
}
</code></pre><p>You&#39;ll pass in a Vector3 into the Move method to guide the player along the four compass directions. You can also use a raycast to detect the walls in the appropriate LayerMask. Of course, implementing what you want to apply to the command pattern is separate from the pattern itself.</p>
<p><img src="_page_63_Figure_0.jpeg" alt=""></p>
<p>Player movement in the sample</p>
<p>To follow the command pattern, capture the PlayerMover&#39;s Move method as an object. Instead of calling Move directly, create a new class, MoveCommand, that implements the ICommand interface:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoveCommand</span> : <span class="hljs-title">ICommand</span>
{
 PlayerMover playerMover;
 Vector3 movement;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoveCommand</span>(<span class="hljs-params">PlayerMover player, Vector3 moveVector</span>)
 </span>{
 <span class="hljs-keyword">this</span>.playerMover = player;
 <span class="hljs-keyword">this</span>.movement = moveVector;
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"></span>)
 </span>{
 playerMover.Move(movement);
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>(<span class="hljs-params"></span>)
 </span>{
 playerMover.Move(-movement);
 }
}
</code></pre><p>ICommand requires an Execute method to store what you&#39;re trying to accomplish. Whatever logic you want to accomplish goes in here, so invoke Move with the movement vector.</p>
<p>ICommand also needs an Undo method to restore the scene back to its previous state. In this case, the Undo logic subtracts the movement vector, essentially pushing the player in the opposite direction.</p>
<p>The MoveCommand stores any parameters that it needs to execute. Set these up with a constructor. In this case, you save the appropriate PlayerMover component and the movement vector.</p>
<p>Once you create the command object and save its needed parameters, use the CommandInvoker&#39;s static ExecuteCommand and UndoCommand methods to pass in your MoveCommand. This runs the MoveCommand&#39;s Execute or Undo and tracks the command object in the undo stack.</p>
<p><img src="_page_64_Figure_2.jpeg" alt=""></p>
<p>The CommandInvoker, ICommand, and MoveCommand</p>
<p>The InputManager doesn&#39;t call the PlayerMover&#39;s Move method directly. Instead, add an extra method, RunMoveCommand, to create a new MoveCommand and send it to the CommandInvoker.</p>
<pre><code><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RunPlayerCommand</span><span class="hljs-params">(PlayerMover playerMover, Vector3 move-
ment)</span>
</span>{
 <span class="hljs-keyword">if</span> (playerMover == <span class="hljs-keyword">null</span>)
 {
 <span class="hljs-keyword">return</span>;
 }
 <span class="hljs-keyword">if</span> (playerMover.IsValidMove(movement))
 {
 ICommand command = <span class="hljs-keyword">new</span> MoveCommand(playerMover, movement);
 CommandInvoker.ExecuteCommand(command);
 }
}
</code></pre><p>Then, set up the various onClick events of the UI Buttons to call RunPlayerCommand with the four movement vectors.</p>
<p>Check out the sample project for implementation details for the InputManager or set up your own input using the keyboard or gamepad. Your player can now navigate the maze. Click the Undo button so you can backtrack to the beginning square.</p>
<h4 id="pros-and-cons">Pros and cons</h4>
<p>Implementing replayability or undoability is as simple as generating a collection of command objects. You can also use the command buffer to play back actions in sequence with specific controls.</p>
<p>For example, think about a fighting game where a series of specific button clicks triggers a combo move or attack. Storing player actions with the command pattern makes setting up such combos much simpler.</p>
<p>On the flip side, the command pattern introduces more structure, just like the other design patterns. You&#39;ll have to decide where these extra classes and interfaces provide enough benefit for deploying command objects in your application.</p>
<h4 id="-span-id-page-66-0-span-improvements"><span id="page-66-0"></span>Improvements</h4>
<p>Once you learn the basics, you can affect the timing of commands and play them back in succession or reverse, depending on the context.</p>
<p>Consider the following when incorporating the command pattern:</p>
<ul>
<li><strong>Create more commands:</strong> The sample project only includes one type of command object, the MoveCommand. You can create any number of command objects that implement ICommand and track them using the CommandInvoker.</li>
<li><strong>Adding redo functionality is a matter of adding another stack:</strong> When you undo a command object, push it onto a separate stack that tracks redo operations. This way you can quickly cycle through the undo history or redo those actions. Clear out the redo stack when the user invokes an entirely new movement (you can find an implementation in the accompanying sample project).</li>
</ul>
<p><img src="_page_66_Figure_5.jpeg" alt=""></p>
<p>Undo and redo stacks</p>
<p>— <strong>Use a different collection for your buffer of command objects:</strong> A queue might be handier if you want first in, first out (FIFO) behavior. If you use a list, track the currently active index; commands before active index are undoable. Commands after the index are redoable.</p>
<p><img src="_page_67_Figure_0.jpeg" alt=""></p>
<p>A list or other collection acts as a command buffer.</p>
<ul>
<li><strong>Limit the size of the stacks:</strong> Undo and redo operations can quickly blow up out of control. Limit the stacks to the last number of commands.</li>
<li><strong>Pass any necessary parameters into the constructor:</strong> This helps encapsulate the logic as seen in the MoveCommand example.</li>
</ul>
<p>The CommandInvoker, like other external objects, doesn&#39;t see the inner workings of the command object, only invoking Execute or Undo. Give the command object any data needed to work when calling the constructor.</p>
<h3 id="-span-id-page-68-0-span-state-pat-tern"><span id="page-68-0"></span>STATE PAT TERN</h3>
<p><span id="page-69-0"></span>Imagine constructing a playable character. At one moment, the character may be standing on the ground. Move the controller, and it appears to run or walk. Press the jump button and the character leaps into midair. A few frames later, it lands and reenters its idle, standing position.</p>
<h4 id="states-and-state-machines">States and state machines</h4>
<p>Games are interactive, and they force us to track many systems that change at runtime. If you draw a <a href="https://en.wikipedia.org/wiki/State_diagram">diagram</a> that represents the different states of your character, you might come up with something like this:</p>
<p><img src="_page_69_Figure_3.jpeg" alt=""></p>
<p>A simple state diagram</p>
<p>It resembles a flowchart with a few differences:</p>
<ul>
<li>The diagram consists of a number of states (Idling/Standing, Walking, Running, Jumping, and so on), and only one current state is active at a given time.</li>
<li>Each state can trigger a transition to one other state based on conditions at runtime.</li>
<li>When a transition occurs, the output state becomes the new active state.</li>
</ul>
<p>This diagram describes something called a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite-state machine</a> (FSM). In game development, one typical use case is for tracking the internal state of a game actor or prop.</p>
<p>To describe a basic FSM in code, you might use a naive approach with an enum and a switch statement.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> PlayerControllerState
{
 Idle,
 Walk,
 Jump
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnrefactoredPlayerController</span> : <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-keyword">private</span> PlayerControllerState state;
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)
 </span>{
 GetInput();
 <span class="hljs-keyword">switch</span> (state)
 {
 <span class="hljs-keyword">case</span> PlayerControllerState.Idle:
 Idle();
 <span class="hljs-keyword">break</span>;
 <span class="hljs-keyword">case</span> PlayerControllerState.Walk:
 Walk();
 <span class="hljs-keyword">break</span>;
 <span class="hljs-keyword">case</span> PlayerControllerState.Jump:
 Jump();
 <span class="hljs-keyword">break</span>;
 }
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetInput</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// process walk and jump controls</span>
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Walk</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// walk logic</span>
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Idle</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// idle logic</span>
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Jump</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// jump logic</span>
 }
}
</code></pre><p>This would work, but the PlayerController script can get messy quickly. Adding more states and complexity requires us to revisit the PlayerController script&#39;s internals each time.</p>
<h4 id="-span-id-page-71-0-span-example-simple-state-pattern"><span id="page-71-0"></span>Example: Simple state pattern</h4>
<p>Fortunately, the <a href="https://en.wikipedia.org/wiki/State_pattern">state pattern</a> can help you reorganize the logic. According to the original Gang of Four, the state pattern solves two problems:</p>
<ul>
<li>An object should change its behavior when its internal state changes.</li>
<li>State-specific behavior is defined independently. Adding new states does not impact the behavior of existing states.</li>
</ul>
<p>While the above example UnrefactoredPlayerController class can track state changes, it does not satisfy the second issue. You want to minimize the impact on existing states when you add new ones. Instead, you can encapsulate a state as an object.</p>
<p><img src="_page_71_Figure_5.jpeg" alt=""></p>
<p>Imagine structuring each state like this:</p>
<p>The encapsulated state with an Entry, Exit, and Update</p>
<p>Here you enter the state and loop each frame until a condition causes control flow to exit. To implement this pattern, create an interface, IState:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IState</span>
{
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// code that runs when we first enter the state</span>
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// per-frame logic, include condition to transition to a new </span>
state
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// code that runs when we exit the state</span>
 }
}
</code></pre><p>Each concrete state in your game will implement the IState interface:</p>
<ul>
<li><strong>An Entry:</strong> This logic executes when first entering the state.</li>
<li><strong>Update:</strong> This logic runs every frame (sometimes called Execute or Tick). You can further segment the Update method as MonoBehaviour does, using a FixedUpdate for physics, LateUpdate, and so on.</li>
</ul>
<p>Any functionality in the Update runs each frame until a condition is detected that triggers a state change.</p>
<p>— <strong>An Exit:</strong> Code here runs before leaving the state and transitioning to a new state.</p>
<p>You&#39;ll need to create a class for each state that implements IState. In the sample project, a separate class has been set up for WalkState, IdleState, and JumpState.</p>
<p>Another class, the StateMachine, will then manage how control flow enters and exits the states. With the three example states, the StateMachine could look like this:</p>
<pre><code>[Serializable]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StateMachine</span>
{
 <span class="hljs-keyword">public</span> IState CurrentState { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
 <span class="hljs-keyword">public</span> WalkState walkState;
 <span class="hljs-keyword">public</span> JumpState jumpState;
 <span class="hljs-keyword">public</span> IdleState idleState;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span>(<span class="hljs-params">IState startingState</span>)
 </span>{
 CurrentState = startingState;
 startingState.Enter();
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TransitionTo</span>(<span class="hljs-params">IState nextState</span>)
 </span>{
 CurrentState.Exit();
 CurrentState = nextState;
 nextState.Enter();
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (CurrentState != <span class="hljs-literal">null</span>)
 {
 CurrentState.Update();
 }
 }
}
</code></pre><p>To follow the pattern, the StateMachine references a public object for each state under its management (in this case, walkState, jumpState, and idleState). Because StateMachine doesn&#39;t inherit from MonoBehaviour, use a constructor to set up each instance:</p>
<pre><code><span class="hljs-keyword">public</span> StateMachine(PlayerController player)
{
 <span class="hljs-built_in">this</span>.walkState = <span class="hljs-keyword">new</span> <span class="hljs-type">WalkState</span>(player);
 <span class="hljs-built_in">this</span>.jumpState = <span class="hljs-keyword">new</span> <span class="hljs-type">JumpState</span>(player);
 <span class="hljs-built_in">this</span>.idleState = <span class="hljs-keyword">new</span> <span class="hljs-type">IdleState</span>(player);
}
</code></pre><p>You can pass in any parameters needed to the constructor. In the sample project, a PlayerController is referenced in each state. You then use that to update each state per frame (see the IdleState example below).</p>
<p>Note the following about the StateMachine:</p>
<ul>
<li>The Serializable attribute allows us to display the StateMachine (and its public fields) in the Inspector. Another MonoBehaviour (e.g., a PlayerController or EnemyController) can then use the StateMachine as a field.</li>
<li>The CurrentState property is read-only. The StateMachine itself does not explicitly set this field. An external object like the PlayerController can then invoke the Initialize method to set the default State.</li>
<li>Each State object determines its own conditions for calling the TransitionTo method to change the currently active state. You can pass in any necessary dependencies (including the State Machine itself) to each state when setting up the StateMachine instance.</li>
</ul>
<p>In the example project, the PlayerController already includes a reference to the StateMachine, so you only pass in one player parameter.</p>
<p>Each state object will manage its own internal logic, and you can make as many states as needed to describe your GameObject or component. Each one gets its own class that implements IState. In keeping with the SOLID principles, adding more states has minimal impact on any previously created states.</p>
<p>Here&#39;s an example of the IdleState:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IdleState</span> : <span class="hljs-title">IState</span>
{
 <span class="hljs-keyword">private</span> PlayerController player;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdleState</span>(<span class="hljs-params">PlayerController player</span>)
 </span>{
 <span class="hljs-keyword">this</span>.player = player;
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// code that runs when we first enter the state</span>
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)
 </span>{ 
 <span class="hljs-comment">// Here we add logic to detect if the conditions exist to </span>
 <span class="hljs-comment">// transition to another state</span>
 …
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// code that runs when we exit the state</span>
 }
}
</code></pre><p><span id="page-75-0"></span>Again, use the constructor to pass in the PlayerController object. In the example, this player contains a reference to the StateMachine and everything else needed for the Update logic. The idleState monitors the Character Controller&#39;s velocity or jump state and then invokes the StateMachine&#39;s TransitionTo method appropriately.</p>
<p>Review the sample project for the WalkState and JumpState implementation as well. Rather than have one large class that switches behavior, each state has its own update logic. This way, states can function independently from one another.</p>
<h4 id="pros-and-cons">Pros and cons</h4>
<p>The state pattern can help you adhere to the SOLID principles when setting up internal logic for an object. Each state is relatively small and just tracks the conditions for transitioning into another state. In keeping with the open-closed principle, you can add more states without affecting existing ones and avoid cumbersome switch or if statements.</p>
<p>On the other hand, if you only have a few states to track, the extra structure can be overkill. This pattern might only make sense if you expect your states to grow to a certain complexity.</p>
<p><img src="_page_75_Figure_5.jpeg" alt=""></p>
<p>The state pattern sample</p>
<h4 id="improvements">Improvements</h4>
<p>The capsule in the sample project changes color, and the UI updates with the player&#39;s internal state. In a real-world example, you could have much more complex effects to accompany the state changes:</p>
<p>— <strong>Combine the state pattern with animation:</strong> One common application for the state pattern is animation. The player or enemy characters are often represented as primitives (a capsule) on a macro level. Then, you can have animated geometry that reacts to internal state changes, so the game actor can appear to be running, jumping, swimming, climbing, etc.</p>
<p>If you&#39;ve used Unity&#39;s Animator window, you&#39;ll notice that its workflow pairs well with the state pattern. Each animation clip occupies one state, with only one state active at a time.</p>
<p><img src="_page_76_Figure_2.jpeg" alt=""></p>
<p>An example of an Animator state graph: Compare its structure with a StateMachine.</p>
<ul>
<li><strong>Add events:</strong> To communicate state changes to outside objects, you might want to add events (see the <a href="#page-78-0">observer pattern)</a>. Having an event on entering or exiting a state can notify the relevant listeners and have them respond at runtime.</li>
<li><strong>Add a hierarchy:</strong> As you begin to describe more complex entities with the state pattern, you might want to implement hierarchical state machines. Inevitably some states will be similar; for example, if the player or game actor is grounded, it can duck or jump whether in a WalkingState or RunningState.</li>
</ul>
<p>If you implement a SuperState, you can keep common behaviors together. Then using inheritance, you can override anything specific in a sub-state. For example, you might first declare a GroundedState. You could then inherit a RunningState or WalkingState from that.</p>
<p>— <strong>Implement simple AI:</strong> Finite-state machines can also be useful in generating basic enemy AI. An FSM approach to building an NPC brain might look like this:</p>
<p><img src="_page_77_Figure_2.jpeg" alt=""></p>
<p>A simple AI based on state patterns</p>
<p>Here&#39;s the state pattern at work again in a completely different context. Every state represents an action, such as attacking, fleeing, or patrolling. Only one state is active at a time, with each state determining its transition to the next one.</p>
<h3 id="-span-id-page-78-0-span-observer-pat-tern"><span id="page-78-0"></span>OBSERVER PAT TERN</h3>
<p>© 2022 Unity Technologies <strong>79 of 99</strong> | unity<a href="https://unity.com/">.com</a></p>
<p><span id="page-79-0"></span>At runtime, any number of things can occur in your game. What happens when you destroy an enemy? How about when you collect a power-up or complete an object? You often need a mechanism that allows some objects to notify others without directly referencing them, thereby creating unnecessary dependencies.</p>
<p>The observer pattern is a common solution to this sort of problem. It allows your objects to communicate but stay loosely coupled using a &quot;one-to-many&quot; dependency. When one object changes states, all dependent objects get notified automatically. This is analogous to a radio tower that broadcasts to many different listeners.</p>
<p><img src="_page_79_Figure_2.jpeg" alt=""></p>
<p>The observer pattern functions like a radio tower. The subject broadcasts to the observers.</p>
<p>The object that is broadcasting is called the subject. The other objects that are listening are called the observers.</p>
<p>This pattern loosely decouples the subject, which doesn&#39;t really know the observers or care what they do once they receive the signal. While the observers have a dependency on the subject, the observers themselves don&#39;t know about each other.</p>
<h4 id="events">Events</h4>
<p>The observer pattern is so widespread that it&#39;s built into the C# language. You can design your own subject-observer classes but it&#39;s usually unnecessary. Remember the point about reinventing the wheel? C# already implements the pattern using events.</p>
<p>An event is simply a notification that indicates something has happened. It involves a few parts:</p>
<ul>
<li>The publisher (the subject) creates an event based on a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/">delegate</a>, establishing a specific function signature. The event is just some action that the subject will perform at runtime (e.g., take damage, click a button, and so on).</li>
<li>The subscribers (the observers) then each make a method called an event handler, which must match the delegate&#39;s signature.</li>
<li>Each observer&#39;s event handler subscribes to the publisher&#39;s event. You can have as many observers join the subscription as necessary. All of them will wait for the event to trigger.</li>
<li>When the publisher signals the occurrence of an event at runtime, you say that it raises the event. This, in turn, invokes the subscribers&#39; event handlers, which run their own internal logic in response.</li>
</ul>
<p>In this way, you make many components react to a single event from the subject. If the subject indicates that a button is clicked, the observers could play back an animation or sound, trigger a cutscene, or save a file. Their response could be anything, which is why you&#39;ll frequently find the observer pattern used to send messages between objects.</p>
<p><img src="_page_80_Figure_6.jpeg" alt=""></p>
<p>The subject raises the event to notify the observers.</p>
<h4 id="-span-id-page-81-0-span-example-simple-subject-and-observer"><span id="page-81-0"></span>Example: Simple subject and observer</h4>
<p>For example, you might define a basic subject/publisher like this:</p>
<pre><code><span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>: <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action ThingHappened;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoThing</span>(<span class="hljs-params"></span>)
 </span>{
 ThingHappened?.Invoke();
 }
}
</code></pre><p>Here, you inherit from MonoBehaviour to attach to a GameObject more easily, but that&#39;s not required.</p>
<p>While you are free to define your own custom delegate, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action?view=net-6.0">System.Action</a> works in most cases. If you need to send parameters with the event, use the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-1?view=net-6.0">Action<T></a> delegate and pass them as a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0">List<T></a> within the angle brackets (up to 16 parameters).</p>
<p>ThingHappened is the actual event, which the subject invokes in the DoThing method.</p>
<p>To listen to the event, you can build an example Observer class. Here you inherit from MonoBehaviour for convenience, but that&#39;s not required.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> : <span class="hljs-title">MonoBehaviour</span>
{
 [SerializeField] <span class="hljs-keyword">private</span> Subject subjectToObserve;
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnThingHappened</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-comment">// any logic that responds to event goes here</span>
 Debug.Log(<span class="hljs-string">"Observer responds"</span>);
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (subjectToObserve != <span class="hljs-literal">null</span>)
 {
 subjectToObserve.ThingHappened += OnThingHappened;
 }
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (subjectToObserve != <span class="hljs-literal">null</span>)
 {
 subjectToObserve.ThingHappened -= OnThingHappened;
 }
 }
}
</code></pre><p>Attach this component to a GameObject and reference the subjectToObserver in the Inspector order to listen for the ThingHappened event.</p>
<p>The OnThingHappened method can contain any logic the observer executes in response to the event. Often developers add the prefix &quot;On&quot; to denote the event handler (just use the naming convention from your style guide).</p>
<p>In the Awake or Start, you can subscribe to the event with the += operator. That <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-combine-delegates-multicast-delegates">combines</a> the observer&#39;s OnThingHappened method with the subject&#39;s ThingHappened.</p>
<p>If anything runs the subject&#39;s DoThing method, that raises the event. Then, the observer&#39;s OnThingHappened event handler invokes automatically and prints the debug statement.</p>
<p>Note: If you delete or remove the observer at runtime while it&#39;s still subscribed to the ThingHappened, calling that event could result in an error. Thus, it&#39;s important to unsubscribe from the event in the MonoBehaviour&#39;s OnDestroy method with -= operator.</p>
<p>You can apply the observer pattern to nearly everything that happens during the course of gameplay. For example, your game could raise an event every time the player destroys an enemy or collects an item. If you need a statistics system that tracks scores or achievements, the observer pattern could allow you to create one without affecting the original gameplay code.</p>
<p>Many Unity applications apply events to:</p>
<ul>
<li>Objectives or goals</li>
<li>Win/lose conditions</li>
<li>PlayerDeath, EnemyDeath, or Damage</li>
<li>Item pickups</li>
<li>User interface</li>
</ul>
<p>The subject simply needs to raise an event at the opportune time, and then any number of observers can subscribe.</p>
<p><img src="_page_83_Picture_7.jpeg" alt=""></p>
<p>The observer sample scene</p>
<p>In the sample project, the ButtonSubject allows the user to invoke a Clicked event with the mouse button. Several other GameObjects with the AudioObserver and ParticleSystemObserver components can then respond in their own ways to the event.</p>
<p>Determining which object is a &quot;subject&quot; and which one is an &quot;observer&quot; only varies by usage. Anything that raises the event acts as the subject, and anything that responds to the event is the observer. Different components on the same GameObject can be subjects or observers. Even the same component can be a subject in one context and an observer in another.</p>
<p>For instance, the AnimObserver in the example adds a little bit of movement to the button when clicked. It acts as an observer even though it&#39;s part of the ButtonSubject GameObject.</p>
<h4 id="-span-id-page-84-0-span-unityevents-and-unityactions-"><span id="page-84-0"></span><strong>UnityEvents and UnityActions</strong></h4>
<p>Unity also includes a separate system of <a href="https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UnityEvents,</a> which uses the <a href="https://docs.unity3d.com/ScriptReference/Events.UnityAction.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UnityAction</a> delegate from the <strong>UnityEngine.Events</strong> API.</p>
<p>UnityEvents provide a graphical interface for the observer pattern. If you&#39;ve used Unity&#39;s UI system (e.g., creating a <a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-Button.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UI Button</a>&#39;s OnClick event), you already have some experience with it.</p>
<table>
<thead>
<tr>
<th>▼ ● √ Button</th>
<th></th>
<th>2<br>?</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Interactable</td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Transition</td>
<td>Color Tint</td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Target Graphic</td>
<td>Button (Legacy) (Image)</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Normal Color</td>
<td></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>Highlighted Color</td>
<td></td>
<td></td>
<td>20</td>
</tr>
<tr>
<td>Pressed Color</td>
<td></td>
<td></td>
<td>Sp</td>
</tr>
<tr>
<td>Selected Color</td>
<td></td>
<td></td>
<td>8</td>
</tr>
<tr>
<td>Disabled Color</td>
<td></td>
<td></td>
<td>00</td>
</tr>
<tr>
<td>Color Multiplier</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fade Duration</td>
<td>0.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Navigation</td>
<td>Automatic</td>
<td></td>
<td>D</td>
</tr>
<tr>
<td></td>
<td>Visualize</td>
<td></td>
<td></td>
</tr>
<tr>
<td>On Click ()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Runtime Only</td>
<td>- AudioObserver.OnThingHappened</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AudioObserver (Au O</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Runtime Only</td>
<td>- AudioObserver.OnThingHappened</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AudioObserver (Au O</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>+</td>
</tr>
</tbody>
</table>
<p>UnityEvents have graphical components for your setup</p>
<p>In this example, the button&#39;s OnClick event invokes and triggers a response from the two AudioObservers&#39; OnThingHappened methods. You can thus set up a subject&#39;s event without code.</p>
<p>UnityEvents are useful if you want to allow designers or nonprogrammers to create gameplay events. However, be aware that they may be slower than their equivalent events or actions from the System namespace.</p>
<p>Weigh performance versus usage when considering UnityEvents and UnityActions. See the <a href="https://learn.unity.com/tutorial/create-a-simple-messaging-system-with-events?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Create a Simple Messaging System with Events</a> module on Unity Learn for an example.</p>
<h4 id="-span-id-page-85-0-span-pros-and-cons"><span id="page-85-0"></span>Pros and cons</h4>
<p>Implementing an event adds some extra work but does offer advantages:</p>
<ul>
<li><strong>The observer pattern helps decouple your objects:</strong> The event publisher does not need to know anything about the event subscribers themselves. Instead of creating a direct dependency between one class and another, the subject and observer communicate while maintaining a degree of separation.</li>
<li><strong>You don&#39;t have to build it:</strong> C# includes an established event system, and you can use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action?view=net-6.0">System.Action</a> delegate instead of defining your own delegates. Alternatively, Unity also includes <a href="https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UnityEvents</a> and <a href="https://docs.unity3d.com/ScriptReference/Events.UnityAction.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UnityActions.</a></li>
<li><strong>Each observer implements its own event handling logic:</strong> In this way, each observing object maintains the logic it needs to respond. This makes it easier to debug and unit test.</li>
<li><strong>It&#39;s well-suited for user interface:</strong> Your core gameplay code can live separately from your UI logic. Your UI elements then listen for specific game events or conditions and respond appropriately. The <a href="#page-87-0">MVP and MVC</a>  <a href="#page-87-0">patterns</a> use the observer pattern for this purpose.</li>
</ul>
<p>Be aware of these caveats for the observer pattern:</p>
<ul>
<li><strong>It adds additional complexity:</strong> Like other patterns, creating event-driven architecture does require more setup up front. Also, be careful deleting subjects or observers. Make sure you unregister observers in OnDestroy.</li>
<li><strong>The observers need a reference to the class that defines the event:</strong>  Observers still have a dependency to the class that is publishing the event. Using a static EventManager (below) that handles all events can help disentangle objects from each other.</li>
<li><strong>Performance can be an issue:</strong> Event-driven architecture adds extra overhead. Large scenes and many GameObjects can hinder performance.</li>
</ul>
<h4 id="improvements">Improvements</h4>
<p>While only a basic version of the observer pattern is introduced here, you can expand this to handle all of your game application&#39;s needs.</p>
<p>Consider these suggestions when setting up the observer pattern:</p>
<ul>
<li><strong>Use the ObservableCollection class:</strong> C# provides a dynamic <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=net-5.0">ObservableCollection</a> to track specific changes. It can notify your observers when items get added, removed, or when the list is refreshed.</li>
<li><strong>Pass a unique instance ID as an argument:</strong> Each GameObject in the hierarchy has a unique <a href="https://docs.unity3d.com/ScriptReference/Object.GetInstanceID.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">instance ID</a>. If you trigger an event that could apply to more than one observer, pass the unique ID into the event (use type <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-1?view=net-6.0">Action<int></a>). Then only run the logic in the event handler if the GameObject matches the unique ID.</li>
</ul>
<p>— <strong>Create a static EventManager:</strong> Because events can drive much of your gameplay, many Unity applications use a static or singleton EventManager. This way, your observers can reference a central source of game events as the subject to make setup easier.</p>
<p>The <a href="https://learn.unity.com/project/fps-template?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">FPS Microgame</a> has a good implementation of a static EventManager which implements custom GameEvents and includes static helper methods to add or remove listeners.</p>
<p>The <a href="https://unity.com/open-projects?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Unity Open Project</a> also showcases a game architecture that uses <a href="https://www.youtube.com/watch?v=WLDgtRNK2VE?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">ScriptableObjects to relay UnityEvents.</a> It uses events to play audio or load new scenes.</p>
<p>— <strong>Create an event queue:</strong> If you have a lot of objects in your scene, you might not want to raise your events all at once. Imagine the cacophony of a thousand objects playing back sounds when you invoke a single event.</p>
<p>Combining the observer pattern with the command pattern allows you to encapsulate your events into an event queue. Then you can use a command buffer to play back the events one at a time or selectively ignore them as necessary (e.g., if you have a maximum number of objects that can make sounds at once).</p>
<p>The observer pattern heavily figures into the Model View Presenter (MVP) architectural pattern, which is covered in more detail in the next chapter.</p>
<h2 id="-span-id-page-87-0-span-m-o-d-e-l-v-i-e-w-presenter-mvp-"><span id="page-87-0"></span>M O D E L V I E W PRESENTER (MVP)</h2>
<p>© 2022 Unity Technologies <strong>88 of 99</strong> | unity<a href="https://unity.com/">.com</a></p>
<p><span id="page-88-0"></span>Model View Controller (MVC) is a family of design patterns commonly used when developing user interfaces.</p>
<p>The general idea behind MVC is to separate the logical portion of your software from the data and from the presentation. This helps reduce unnecessary dependencies and potentially cut down on <a href="https://en.wikipedia.org/wiki/Spaghetti_code">spaghetti code.</a></p>
<h4 id="model-view-controller-mvc-design-pattern">Model View Controller (MVC) design pattern</h4>
<p>As the name implies, the MVC pattern splits your application into three layers:</p>
<ul>
<li><strong>The Model stores data:</strong> The Model is strictly a data container that holds values. It does not perform gameplay logic or run calculations.</li>
<li><strong>The View is the interface:</strong> The View formats and renders a graphical presentation of your data onscreen.</li>
<li><strong>The Controller handles logic:</strong> Think of this as the brain. It processes the game data and calculates how the values change at runtime.</li>
</ul>
<p><img src="_page_88_Figure_7.jpeg" alt=""></p>
<p>The Model, View, and Controller</p>
<p>This separation of concerns also specifically defines how these three parts interact with one another. The Model manages the application data, while the View displays that data to the user. The Controller handles input and performs any decisions or calculations on the game data. Then it sends the results back to the Model.</p>
<p><span id="page-89-0"></span>Thus, the Controller does not contain any game data unto itself. Nor does the View. The MVC design limits what each layer does. One part holds the data, another part processes the data, and the last one displays that data to the user.</p>
<p>On the surface, you can think of this as an extension of the single-responsibility principle. Each part does one thing and does it well, which is one advantage of MVC architecture.</p>
<h4 id="model-view-presenter-mvp-and-unity">Model View Presenter (MVP) and Unity</h4>
<p>When developing a Unity project with MVC, the existing UI framework (either the <a href="https://docs.unity3d.com/Manual/UIElements.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">UI Toolkit</a> or <a href="https://docs.unity3d.com/Manual/com.unity.ugui.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Unity UI)</a> naturally functions as the View. Because the engine gives you a complete user interface implementation, you won&#39;t need to develop individual UI components from scratch.</p>
<p>However, following the traditional MVC pattern would require View-specific code to listen for any changes in the Model&#39;s data at runtime.</p>
<p>While this is a valid approach, many Unity developers opt to use a variation on MVC where the Controller acts as an intermediary. Here, the View doesn&#39;t directly observe the Model. Instead, it does something like this:</p>
<p><img src="_page_89_Figure_6.jpeg" alt=""></p>
<p>This variation on MVC is called the Model View Presenter design, or MVP. MVP still preserves the separation of concerns with three distinct application layers. However, it slightly changes each part&#39;s responsibilities.</p>
<p>In MVP, the Presenter (called the Controller in MVC) acts as a go-between for the other layers. It retrieves data from the Model and then formats it for display in the View. MVP switches which layer handles input. Rather than the Controller, the View is responsible for handling user input.</p>
<p>Notice how events and the observer pattern figure into this design. The user can interact with Unity UI&#39;s Button, Toggle, and Slider components. The View layer sends this input back to the Presenter via UI events, and the Presenter, in turn, manipulates the Model. A state-change event from the Model tells the Presenter that the data has been updated. The Presenter passes the modified data to the View, which MVP: A variation on MVC refreshes the UI.</p>
<h4 id="-span-id-page-90-0-span-example-health-interface"><span id="page-90-0"></span>Example: Health interface</h4>
<p>To formalize an MVP example, imagine a simple system to show the health of a character or item. You could stuff everything into one class that mixes the data and UI, but that wouldn&#39;t scale well. Adding more functionality would become more complicated as you need to expand it.</p>
<p>Instead, you can rewrite your health components in a more MVP-centric way. Divide your scripts into a Health and HealthPresenter. The Health component could look like this:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Health</span>: <span class="hljs-title">MonoBehaviour</span>
{
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action HealthChanged;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> minHealth = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxHealth = <span class="hljs-number">100</span>;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentHealth;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> CurrentHealth { <span class="hljs-keyword">get</span> =&gt; currentHealth; <span class="hljs-keyword">set</span> =&gt; current-
Health = <span class="hljs-keyword">value</span>; }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MinHealth =&gt; minHealth;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MaxHealth =&gt; maxHealth;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Increment</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> amount</span>)
 </span>{
 currentHealth += amount;
 currentHealth = Mathf.Clamp(currentHealth, minHealth, max-
Health);
 UpdateHealth();
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Decrement</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> amount</span>)
 </span>{
 currentHealth -= amount;
 currentHealth = Mathf.Clamp(currentHealth, minHealth, max-
Health);
 UpdateHealth();
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Restore</span>(<span class="hljs-params"></span>)
 </span>{
 currentHealth = maxHealth;
 UpdateHealth();
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateHealth</span>(<span class="hljs-params"></span>)
 </span>{
 HealthChanged?.Invoke();
 }
}
</code></pre><p>In this version, Health serves as the Model. It stores the actual health value and invokes an event, HealthChanged, every time that value changes. Health does not contain gameplay logic, only methods to increment and decrement the data.</p>
<p>Most objects, however, won&#39;t manipulate the Health itself. You&#39;ll reserve a HealthPresenter for that task:</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HealthPresenter</span> : <span class="hljs-title">MonoBehaviour</span>
{
 [SerializeField] Health health;
 [SerializeField] Slider healthSlider;
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (health != <span class="hljs-literal">null</span>)
 {
 health.HealthChanged += OnHealthChanged;
 }
 UpdateView();
 }
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (health != <span class="hljs-literal">null</span>)
 {
 health.HealthChanged -= OnHealthChanged;
 }
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Damage</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> amount</span>)
 </span>{
 health?.Decrement(amount);
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Heal</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> amount</span>)
 </span>{
 health?.Increment(amount);
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>(<span class="hljs-params"></span>)
 </span>{
 health?.Restore();
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateView</span>(<span class="hljs-params"></span>)
 </span>{
 <span class="hljs-keyword">if</span> (health == <span class="hljs-literal">null</span>)
 <span class="hljs-keyword">return</span>;
 <span class="hljs-keyword">if</span> (healthSlider !=<span class="hljs-literal">null</span> &amp;&amp; health.MaxHealth != <span class="hljs-number">0</span>)
 {
 healthSlider.<span class="hljs-keyword">value</span> = (<span class="hljs-keyword">float</span>) health.CurrentHealth / (<span class="hljs-keyword">float</span>)
health.MaxHealth;
 }
 }
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHealthChanged</span>(<span class="hljs-params"></span>)
 </span>{
 UpdateView();
 }
}
</code></pre><p><span id="page-92-0"></span>Other GameObjects will need to use the HealthPresenter to modify the health values using Damage, Heal, and Reset. The HealthPresenter usually waits to update the user interface with the UpdateView until the Health raises its HealthChanged event. This is useful if setting the values in the Model takes a short duration (e.g., saving values to disk or storing them in a database).</p>
<p><img src="_page_92_Figure_1.jpeg" alt=""></p>
<p>Sample health interface using MVP</p>
<p>In the sample project, the user can click to damage the target object or reset the health with the button. These inform the HealthPresenter (which invokes Damage or Reset) rather than change the Health directly. The UI Text and UI Slider update when the Health raises an event and notifies the HealthPresenter that its values have changed.</p>
<h4 id="pros-and-cons">Pros and cons</h4>
<p>MVP (and MVC) really shine for larger applications. If your game requires a sizable team to develop and you expect to maintain it for a long time after launch, you might benefit from the following:</p>
<p>— <strong>Smooth division of work:</strong> Because you&#39;ve separated the View from the Presenter, developing and updating your user interface can happen nearly independently from the rest of the codebase.</p>
<p>This lets you divide your labor between specialized developers. Do you have expert front-end developers on your team? Let them take care of the View. They can work independently from everyone else.</p>
<p>— <strong>Simplified unit testing with MVP and MVC:</strong> These design patterns separate gameplay logic from the user interface. As such, you can simulate objects to work with your code without actually needing to enter Play mode in the Editor. This can save considerable amounts of time.</p>
<p>— <strong>Readable code that can be maintained:</strong> You&#39;ll tend to make smaller classes with this design pattern, which makes them easier to read. Fewer dependencies usually means fewer places for your software to break and fewer places that might be hiding bugs.</p>
<p>Though MVC and MVP are widespread in web development or enterprise software, often, the benefits won&#39;t be apparent until your application reaches a sufficient size and complexity. You&#39;ll need to consider the following before implementing either pattern in your Unity project:</p>
<ul>
<li><strong>You need to plan ahead:</strong> Unlike the other patterns described in this guide, MVC and MVP are larger architectural patterns. To use one of them, you&#39;ll need to split your classes by responsibility, which takes some organization and requires more work up front.</li>
<li><strong>Not everything in your Unity project will fit the pattern:</strong> In a &quot;pure&quot; MVC or MVP implementation, anything that renders to screen really is part of the View. Not every Unity component is easily split between data, logic, and interface (e.g., a MeshRenderer). Also, simple scripts may not yield many benefits from MVC/MVP.</li>
</ul>
<p>You&#39;ll need to exercise judgment where you can stand to benefit the most from the pattern. Usually, you can let the unit tests guide you. If MVC/MVP can facilitate testing, consider them for that aspect of the application. Otherwise, don&#39;t try to force the pattern onto your project.</p>
<h3 id="-span-id-page-94-0-span-conclusion-"><span id="page-94-0"></span><strong>Conclusion</strong></h3>
<p>If you&#39;re new to software patterns, we hope this guide has helped you understand some of the most common ones you can encounter in Unity development.</p>
<p>Whether it&#39;s a factory for spawning Prefabs or a state pattern for AI, keep these techniques handy as the need arises. Recognizing when and how to apply design patterns can help you tackle your next Unity challenge. Of course, don&#39;t get lost in forcing a specific pattern to fit; not using a pattern is just as important as using one.</p>
<p>A design pattern can speed up your workflow and offer an elegant solution to a recurrent problem when applied correctly. Then, you can concentrate on what&#39;s important: making a fun and unique experience for your players.</p>
<p>So, while you don&#39;t need to reinvent the wheel, you can definitely put your own spin on it.</p>
<p>© 2022 Unity Technologies <strong>95 of 99</strong> | unity<a href="https://unity.com/">.com</a></p>
<h4 id="-other-design-patterns-"><strong>Other design patterns</strong></h4>
<p>This guide is just a small sampling of several well-known design patterns in computing and game development. While we won&#39;t go into their specifics, here&#39;s a brief overview of some others that may be useful to you:</p>
<ul>
<li><strong><a href="https://en.wikipedia.org/wiki/Adapter_pattern">Adapter</a>:</strong> This provides an interface (also called a wrapper) between two unrelated entities so they can work together.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight:</a></strong> If you have a large number of objects, share common properties in the base class and save resources. For example, when designing a forest, take all of the universal properties of a tree and store them in the base Tree class. Then, you don&#39;t need to repeat them in the subclasses (e.g., PineTree, MapleTree, and so on).</li>
<li><strong><a href="https://gameprogrammingpatterns.com/double-buffer.html">Double buffer:</a></strong> This allows you to maintain two sets of array data while your calculations finish. You can then display one set of data while you process the other, which is useful for procedural simulations (e.g., cellular automata) or just rendering things to screen.</li>
<li><strong><a href="https://gameprogrammingpatterns.com/dirty-flag.html">Dirty flag</a>:</strong> This technique allows you to set a boolean if something has changed in your game, but a costly operation has not yet run (e.g., saving to disk or running a physics simulation).</li>
<li><strong><a href="https://gameprogrammingpatterns.com/bytecode.html">Interpreter/Bytecode</a>:</strong> If you want to add modding support or allow non-programmers to extend your game, you can create a simplified language that users can edit in an external text file. The bytecode component can then translate that interpreted language into C# game code.</li>
<li><strong><a href="https://gameprogrammingpatterns.com/subclass-sandbox.html">Subclass sandbox:</a></strong> If you have similar objects with varying behaviors, you can define those behaviors as protected in a parent class. Then the child classes can mix and match to create new combinations.</li>
<li><strong><a href="https://gameprogrammingpatterns.com/type-object.html">Type object</a>:</strong> If you have many varieties of a GameObject, instead of making subclasses for each one, define all possible behaviors in a single abstract or parent class. Differentiate the special characteristics of individual objects in a separate data file (such as a ScriptableObject) that can be customized without changing the code. For example, this allows you to create an inventory of seemingly different items that all derive from the same class. A game designer can customize the data file to make each item unique (e.g., weapons for an RPG), all without the assistance of a programmer.</li>
<li><strong><a href="https://gameprogrammingpatterns.com/data-locality.html">Data locality</a>:</strong> If you optimize data so that it&#39;s stored efficiently in memory, you can reap the rewards of performance. Replacing classes with structs can make your data more cache-friendly. Unity&#39;s <a href="https://unity.com/dots?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">ECS and DOTS</a> architecture implement this pattern.</li>
<li><strong><a href="https://gameprogrammingpatterns.com/spatial-partition.html">Spatial partitioning:</a></strong> With large scenes and game worlds, use special structures to organize your GameObjects by position. The <a href="https://en.wikipedia.org/wiki/Grid_(spatial_index">Grid</a>), Trie (<a href="https://en.wikipedia.org/wiki/Quadtree">Quadtree,</a> <a href="https://en.wikipedia.org/wiki/Octree">Octree)</a>, and <a href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary search tree</a> are all techniques to help you divide and search more efficiently.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Decorator_pattern">Decorator:</a></strong> This allows you to add responsibilities to an object without changing its existing structure. A decorator could imbue special abilities or modify a GameObject, e.g., adding perks to a weapon without needing to change the base weapon class.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Facade_pattern">Facade:</a></strong> This provides a simple, unified interface to a more complex system. If you have a GameObject with separate AI, animation, and sound components, you might add a wrapper class around those components (imagine a Player controller class managing PlayerInput, PlayerAudio, and so on). This facade hides details of the original components and simplifies usage.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Template_method_pattern">Template method:</a></strong> This pattern defers the exact steps of an algorithm into a subclass. For example, you could define a rough skeleton of algorithm or data structure in an abstract class but allow the subclasses to override certain parts without changing the algorithm&#39;s overall structure.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy</a>:</strong> This behavioral pattern (also called a policy pattern) helps you define a family of algorithms and encapsulate each one inside a class. This makes each algorithm (a strategy) interchangeable at runtime. For example, if you created a pathfinding system, you could use the strategy pattern to define multiple algorithms (A*, Dijkstra&#39;s shortest path, and so on) that you could swap during gameplay, depending on context.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite:</a></strong> Use this structural design pattern to organize objects into tree structures and then treat the resulting structure like you would individual objects. You construct the tree from both simple and composite elements (a leaf and a container). Every element implements the same interface so you can run the same behavior recursively on the entire tree.</li>
</ul>
<h4 id="-span-id-page-97-0-span-professional-training-for-unity-creators"><span id="page-97-0"></span>Professional Training for Unity creators</h4>
<p>Unity Professional Training gives you the skills and knowledge to work more productively and collaborate efficiently in Unity. We offer an extensive training catalog designed for professionals in any industry, at any skill level, in multiple delivery formats.</p>
<p>All materials are created by our experienced Instructional Designers in partnership with our engineers and product teams. This means that you always receive the most up-to-date training on the latest Unity tech.</p>
<p><a href="https://unity.com/learn/professionals?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=game-programming-patterns-ebook">Learn more</a> about how Unity Professional Training can support you and your team.</p>
<p><strong>Note:</strong> All Wikipedia references in this e-book were made through a Creative Commons license: <a href="https://creativecommons.org/licenses/by-sa/3.0/">https://creativecommons.org/licenses/</a> <a href="https://creativecommons.org/licenses/by-sa/3.0/">by-sa/3.0/.</a> No Wikipedia authors cited herein have endorsed our work.</p>
<p>© 2022 Unity Technologies <strong>98 of 99</strong> | unity<a href="https://unity.com/">.com</a></p>
<p><img src="_page_98_Picture_0.jpeg" alt=""></p>
<p><a href="https://unity.com/">unity.com</a></p>
</body></html>